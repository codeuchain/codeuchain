###################################################################################################
# CodeUChain (Python) — Full Reference (Graph Model + Opt‑In Typed Evolution)
###################################################################################################

Version: 1.0.x | License: Apache-2.0 | Repo: https://github.com/codeuchain/codeuchain
Compact Cheat Sheet: `docs/python/llm.txt` (start there) — This file is the expanded narrative.

--------------------------------------------------------------------------------
SECTION INDEX
  1. Overview & Mental Model
  2. Imports & Project Layout Patterns
  3. Core Types (Conceptual Interfaces)
  4. Minimal Graph Example (End‑to‑End)
  5. Typed Shapes & Type Evolution
  6. Middleware (Instrumentation Only)
  7. Error Handling & Resilience Patterns
  8. Recommended Patterns (Playbook)
  9. Testing Strategy (Unit + Integration)
 10. Performance & Scaling Guidance
 11. Migration (Untyped → Typed)
 12. Anti‑Patterns & Remedies
 13. FAQ (High Signal)
 14. Glossary (Shared Vocabulary)
 15. TL;DR Summary
 16. References
--------------------------------------------------------------------------------

## 1. Overview & Mental Model
You build a directed async processing graph composed of pure(ish) Links. Each Link reads from an immutable Context (a snapshot), produces a new Context via `insert()` (same generic type) or `insert_as()` (type evolution), then downstream predicates decide which edges receive that new snapshot.

Why immutable Context?
- Deterministic reasoning & snapshot debugging
- Safe concurrent fan‑out (no shared mutation hazards)
- Clear audit trail of enrichment stages

Visual (simplified):
```
[Root Context]
   │ add_link('sum')
   ▼
[Ctx + sum] -- predicate --> add_link('mean') --> [Ctx + sum + mean]
```

The SAME runtime object model powers both typed and untyped usage; typing is compile‑time / lint‑time help only.

## 2. Imports & Project Layout Patterns
Keep framework primitives explicit; custom logic lives in local modules for discoverability.
```python
from codeuchain.core import Context, Link, Chain, Middleware  # framework primitives
from components.middleware import LoggingMiddleware
```
Typed shapes (optional, introduced gradually):
```python
from typing import TypedDict

class InputShape(TypedDict):
    numbers: list[int]

class StatsShape(TypedDict):
    sum: int
    mean: float
```
Layout suggestion (not enforced):
```
components/
  links/        # domain links (parse, enrich, score, etc.)
  chains/       # assembly helpers (BasicChain, composite graphs)
  middleware/   # logging, metrics, timing
  types/        # typed dicts / dataclasses / pydantic models
```

## 3. Core Types (Conceptual Interfaces)
```python
class Context[T]:
    def get(self, key: str, default: Any | None = None) -> Any: ...
    def insert(self, key: str, value: Any) -> Context[T]: ...            # preserve T
    def insert_as[U](self, key: str, value: Any) -> Context[U]: ...      # evolve → U
    def to_dict(self) -> dict[str, Any]: ...

class Link[TIn, TOut]:
    async def call(self, ctx: Context[TIn]) -> Context[TOut]: ...

class ChainGraph:  # BasicChain wrapper in examples
    def add_link(self, name: str, link: Link[Any, Any]) -> None: ...
    def connect(self, from_name: str, to_name: str,
                predicate: Callable[[Context[Any]], bool]) -> None: ...
    def use_middleware(self, mw: Middleware) -> None: ...
    async def run(self, ctx: Context[Any]) -> Context[Any]: ...

class Middleware:
    async def before(self, name: str, ctx: Context[Any]) -> None: ...
    async def after(self, name: str, ctx: Context[Any]) -> None: ...
    async def on_error(self, name: str, ctx: Context[Any], err: Exception) -> None: ...
```

## 4. Minimal Graph Example (from `simple_math.py`)
```python
chain = Chain()
chain.add_link('sum', MathLink('sum'))
chain.add_link('mean', MathLink('mean'))
chain.connect('sum', 'mean', lambda c: c.get('result') is not None)
chain.use_middleware(LoggingMiddleware())

ctx = Context({'numbers': [1,2,3,4,5]})
final_ctx = await chain.run(ctx)
print(final_ctx.get('result'))  # 3.0
```
Key Points:
- Downstream edge only fires if predicate true.
- Context remains immutable: every `insert` returns a new instance preserving prior data.

## 5. Typed Shapes & Type Evolution
`insert` keeps the same generic type parameter (T). `insert_as` returns a widened (or transformed) type U without unsafe casting.
```python
ctx2 = ctx.insert('sum', 15)                 # preserves shape T
ctx3 = ctx2.insert_as('average', 3.0)        # evolves → new shape U
```
Guidelines:
- Use `TypedDict` / dataclasses for stable domain boundaries.
- Evolve only when semantics change (not for every single new key).
- Group related new fields before evolving to reduce churn.

Evolution Demo Flow (see `insert_as_method_demo.py`):
T0(Input) → insert(sum) → T0 → insert_as(average) → T1(Stats) → insert_as(classification) → T2(StatsWithClass)

## 6. Middleware (Instrumentation Only)
Middleware is for cross‑cutting concerns: logging, metrics, tracing, timing. It SHOULD NOT implement domain logic.
```python
class TimingMW:
    async def before(self, name, ctx):
        ctx.insert('_t0', time.perf_counter())  # safe because new Context returned
    async def after(self, name, ctx):
        ...  # measure delta & record
    async def on_error(self, name, ctx, err):
        print('ERROR', name, err)
```
Order: registration order. Keep them minimal (<1ms overhead each). For heavy exports (e.g., metrics batch), buffer and flush out-of-band.

## 7. Error Handling & Resilience Patterns
| Pattern | Scenario | Mechanism |
|---------|----------|----------|
| Terminal catch & classify | Uniform error taxonomy | Final synthetic link or middleware `on_error` |
| Retry wrapper | Transient I/O, flaky network | Higher‑order link decorator |
| Conditional routing | Partial recoverable failure | Predicate edges branch on error tags |
| Fallback computation | Primary fails fast | Two sibling links, first sets flag, predicate chooses fallback |

Conceptual retry wrapper:
```python
def with_retry(link: Link[Any, Any], attempts=3):
    class Retry(Link[Any, Any]):
        async def call(self, ctx):
            last = None
            for _ in range(attempts):
                try:
                    return await link.call(ctx)
                except Exception as e:  # classify optionally
                    last = e
            raise last
    return Retry()
```

## 8. Recommended Patterns (Playbook)
| Pattern | Description | Example File |
|---------|-------------|--------------|
| Graph assembly | Named nodes + predicate edges | `simple_math.py` |
| Staged enrichment | Stepwise type widening | `insert_as_method_demo.py` |
| Typed processing | Generic evolution with shapes | `typed_example.py` |
| Mixed migration | Combine untyped & typed | `typed_vs_untyped_comparison.py` |
| Advanced branching | Routing & retries | `typed_workflow_patterns.py` |

Design Heuristics:
- Favor fewer, sharper context keys.
- Predicates must be pure (depend only on provided Context snapshot).
- Avoid evolution churn: evolve on semantic boundary crossings.
- Keep middleware side‑effect free (besides logging/metrics signals).

## 9. Testing Strategy
Unit test links in isolation; integration test assembled graphs with table‑driven patterns.
```python
import pytest

@pytest.mark.asyncio
async def test_sum_link():
    ctx = Context({'numbers': [1,2,3]})
    out = await SumLink().call(ctx)
    assert out.get('result') == 6
```
Integration pattern:
```python
cases = [([1,2,3], 2.0), ([1], 1.0)]
for nums, expect in cases:
    ctx = Context({'numbers': nums})
    res = await chain.run(ctx)
    assert res.get('result') == expect
```
Typing checks: run `mypy` (optional). Coverage: `pytest --cov`.

## 10. Performance & Scaling Guidance
- Avoid deep copying huge nested payloads (store IDs / references).
- Coalesce external calls (e.g., `asyncio.gather`) inside a single link when safe.
- Profile hot links via timing middleware → eliminate slow serialization.
- Reuse expensive model/serializer instances (inject them; avoid recreation per call).
- Keep per‑link execution ideally < 5ms (domain dependent).

## 11. Migration (Untyped → Typed)
1. Start fully untyped (`Context()` + simple `Link[Any, Any]`).
2. Add `TypedDict` / dataclass definitions around stable boundaries.
3. Replace `insert` with `insert_as` at the point NEW semantic fields appear.
4. Enforce shapes gradually with tooling (mypy/pyright) — no runtime changes needed.
5. Introduce middleware once core logic is stable to observe behavior.

Coexistence Guarantee: untyped and typed graphs interoperate seamlessly.

## 12. Anti‑Patterns & Remedies
| Anti‑Pattern | Risk | Remedy |
|--------------|------|--------|
| Business logic in middleware | Hidden coupling & surprise | Move into dedicated Link |
| Evolution for every key | Noise & version churn | Batch related additions; evolve once |
| Catch‑all swallow | Debugging black hole | Re‑raise or tag & branch explicitly |
| Monolithic context blob | Memory + cognitive overload | Stage enrichment; segment responsibilities |
| Predicate with side effects | Non‑deterministic routing | Pure function over Context only |

## 13. FAQ (High Signal)
Q: Synchronous library usage?  A: Wrap calls inside link `async def call` (run in thread executor if blocking).
Q: Thread safety?             A: Context is immutable; each insert returns a new snapshot.
Q: Partial failures?          A: Tag error / status and branch via predicates.
Q: When to evolve?            A: Only at semantic boundaries introducing cohesive new fields.
Q: Chain reuse?               A: Yes—chains are templates; each run starts with a fresh root Context.

## 14. Glossary
Link: Async transformation unit from Context[TIn] → Context[TOut].
Context: Immutable key/value snapshot (logical data state at a graph point).
Type Evolution: Transition of generic parameter (T → U) via `insert_as`.
Predicate: Function deciding edge traversal based on emitted Context.
Middleware: Instrumentation hooks (`before`, `after`, `on_error`).
Shape: Structured type definition (TypedDict / dataclass) describing a context variant.

## 15. TL;DR Summary
Explicit async link graph + immutable evolving contexts + opt‑in typed evolution + thin instrumentation middleware. Start untyped, evolve only when semantics expand, keep observability orthogonal.

## 16. References
Examples Directory: `packages/python/examples/`
Key Example Files: `simple_math.py`, `insert_as_method_demo.py`, `typed_example.py`, `typed_vs_untyped_comparison.py`, `typed_workflow_patterns.py`
Issues / Support: https://github.com/codeuchain/codeuchain/issues

© 2025 CodeUChain — Apache-2.0