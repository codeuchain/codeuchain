# CodeUChain (JavaScript / TypeScript) – Full LLM Reference

**Name:** CodeUChain (JavaScript/TypeScript)  
**Homepage:** https://github.com/codeuchain/codeuchain/tree/main/packages/javascript  
**Docs:** https://codeuchain.github.io/codeuchain/javascript/  
**Version:** 1.0.0  
**License:** Apache 2.0  
**Repository:** git+https://github.com/codeuchain/codeuchain.git  
**Contact:** https://github.com/codeuchain/codeuchain/issues  
**Authors:** CodeUChain contributors  
**Languages:** TypeScript (first-class) + JavaScript consumers  
**Runtime Targets:** Node.js 18+, Edge (Workers), Modern Browsers (ES2020)  
**Paradigm Keywords:** Composable, Immutable Context, Type Evolution, Selfless Links, Optional Strict Typing

---
## 1. Purpose & Philosophy
Provide a frictionless way to compose stateless async transformations across environments (server, browser, edge) with optional type rigor. TypeScript generics are fully supported, but plain JS remains first-class.

| Principle | TS Expression | JS Expression | Benefit |
|-----------|--------------|--------------|---------|
| Selfless Links | `async call(ctx)` | same | Predictable & testable |
| Immutable Context | `ctx2 = ctx.insert(k,v)` | same | No hidden mutation |
| Type Evolution | `insertAs<U>` -> widens | same semantics | Gradual modeling |
| Mixed Typing | default `<any, any>` | dynamic access | Incremental adoption |
| Middleware Observability | lifecycle hooks | object functions | Instrumentation without coupling |

---
## 2. Architectural Overview
```
Input Payload -> Context<T0>
    | validateLink
    v
Context<T1>
    | parseLink
    v
Context<T2>
    | enrichLink + middleware(before/after/error)
    v
Context<T3>
```
Supports branching (conditional link inclusion), retry decorators, and error routing.

---
## 3. Core TypeScript Types (Representative)
```ts
export interface Context<T = any> {
  get<K extends string = string>(key: K): any;
  has(key: string): boolean;
  insert(key: string, value: any): Context<T>;         // preserve generic T
  insertAs<U>(key: string, value: any): Context<U>;     // evolve to U
  keys(): string[];
  toObject(): Record<string, any>;
}

export interface Link<TInput = any, TOutput = any> {
  call(ctx: Context<TInput>): Promise<Context<TOutput>>;
}

export interface Middleware {
  before?(name: string, ctx: Context<any>): Promise<void> | void;
  after?(name: string, ctx: Context<any>): Promise<void> | void;
  onError?(name: string, ctx: Context<any>, err: Error): Promise<void> | void;
}
```

---
## 4. Installation
```bash
npm install @codeuchain/javascript
# or
yarn add @codeuchain/javascript
# or
pnpm add @codeuchain/javascript
```

---
## 5. Creating Links (TypeScript)
```ts
import { Link, Context } from '@codeuchain/javascript';

interface RawInput { email: string; text: string }
interface Parsed { email: string; tokens: string[] }

class ParseLink implements Link<RawInput, Parsed> {
  async call(ctx: Context<RawInput>): Promise<Context<Parsed>> {
    const email = ctx.get('email');
    if (!email.includes('@')) throw new Error('invalid_email');
    const text = ctx.get('text');
    const tokens = text.split(/\s+/);
    return ctx.insertAs<Parsed>('parsed', { email, tokens });
  }
}
```

### JavaScript (CommonJS)
```js
const { Chain } = require('@codeuchain/javascript');

const validate = {
  async call(ctx) {
    const e = ctx.get('email');
    if (!e || !e.includes('@')) throw new Error('invalid_email');
    return ctx.insert('validated', true);
  }
};
```

---
## 6. Chain Composition & Error Handling
```ts
import { Chain } from '@codeuchain/javascript';

const chain = new Chain()
  .then(new ParseLink())
  .catch((linkName, err, ctx) => ctx.insert('error_tag', err.message));

const start = /* context factory */;
const result = await chain.call(start);
```

Retry decorator (simplified):
```ts
function withRetry<TIn, TOut>(inner: Link<TIn, TOut>, attempts = 3): Link<TIn, TOut> {
  return {
    async call(ctx) {
      let last: any;
      for (let i = 0; i < attempts; i++) {
        try { return await inner.call(ctx); } catch (e) { last = e; }
        await new Promise(r => setTimeout(r, 10 * (i + 1)));
      }
      throw last;
    }
  };
}
```

---
## 7. Middleware Lifecycle
```ts
const metricsMiddleware = {
  before(name, ctx) { ctx.insert('_t0', performance.now()); },
  after(name, ctx) {
    const t0 = ctx.get('_t0');
    if (t0) console.log(`${name} took ${(performance.now() - t0).toFixed(2)}ms`);
  },
  onError(name, ctx, err) { console.error('ERR', name, err.message); }
};
```
Register: `chain.use(metricsMiddleware)` (assuming API parity).

Guidelines:
- Keep side effects small; streaming logs or metrics exporters belong outside hot path.
- Use `onError` for tagging, not swallowing, unless explicitly returning fallback context.

---
## 8. Type Evolution Walkthrough
```ts
interface Stage1 { raw: string }
interface Stage2 { raw: string; tokens: string[] }
interface Stage3 { raw: string; tokens: string[]; sentiment: number }

// Stage1 -> Stage2
ctx = ctx.insertAs<Stage2>('parsed', { raw: ctx.get('raw'), tokens: ctx.get('raw').split(' ') });
// Stage2 -> Stage3
ctx = ctx.insertAs<Stage3>('scored', { ...ctx.get('parsed'), sentiment: 0.91 });
```
Benefits: IDE autocomplete updates at each evolution; runtime still uses same underlying object store.

---
## 9. Testing & TDD
```ts
// Vitest / Jest example
import { Context } from '@codeuchain/javascript';

test('parse link success', async () => {
  const ctx = new Context({ email: 'a@b.com', text: 'hello world' });
  const out = await new ParseLink().call(ctx);
  expect(out.get('parsed').tokens).toHaveLength(2);
});

test('parse link invalid email', async () => {
  const ctx = new Context({ email: 'bad', text: 'hello' });
  await expect(new ParseLink().call(ctx)).rejects.toThrow('invalid_email');
});
```
Table-driven style:
```ts
for (const [email, ok] of [['a@b.com', true], ['x', false]]) {
  const ctx = new Context({ email, text: 'x y' });
  const link = new ParseLink();
  if (ok) await expect(link.call(ctx)).resolves.toBeTruthy();
  else await expect(link.call(ctx)).rejects.toThrow();
}
```

Coverage commands:
```bash
npm run test:coverage
```

---
## 10. Observation & Debugging
Strategies:
- Middleware for metrics / logging / tracing (e.g., OpenTelemetry)
- Dump only keys: `console.log(ctx.keys())`
- Tag errors with classification keys inside `onError`

Debug middleware:
```ts
const debug = { after: (n, ctx) => console.log('DBG', n, ctx.keys()) };
```

---
## 11. Performance Guidance
| Concern | Recommendation |
|---------|---------------|
| Excess object churn | Reuse context only if a mutable variant exists; otherwise rely on small inserts |
| Logging noise | Gate behind env flag |
| Large payloads | Store references / IDs, not giant blobs |
| Parallel work | Use `Promise.all` with sub-chains |
| Serialization | Defer JSON.stringify until boundary |

Micro-benchmark sketch:
```bash
node benchmarks/chain.mjs
```

---
## 12. Advanced Patterns
- Browser + Worker dual build: same links reused, different middleware (e.g., fetch vs node http)
- Edge runtime: minimal cold-start—links are pure
- Fan-out aggregator: spawn multiple derived contexts, merge selective keys
- Progressive enrichment: early normalization → mid classification → final formatting

---
## 13. Migration & Mixed Typing
Start dynamic (`any` defaults). As contracts stabilize, formalize interfaces and swap `insert` → `insertAs<NewShape>`. You can interleave typed and untyped links freely.

---
## 14. Anti-Patterns
| Anti-Pattern | Problem | Remedy |
|--------------|---------|--------|
| Storing entire DOM nodes | Memory leaks | Store stable IDs / data snapshots |
| Doing network IO in middleware unconditionally | Latency inflation | Make it a link or add sampling |
| Overusing `any` post-stabilization | Lost safety | Introduce interfaces incrementally |
| Silent catches returning empty context | Hides errors | Tag & rethrow or central catch |
| Stuffing secrets in context | Security risk | Use secure vault / env injection |

---
## 15. FAQ
**Q:** Can I use ESM + CJS?  
**A:** Yes—package should export dual modules.

**Q:** Is context mutable?  
**A:** Immutable by contract—each insert returns a new wrapper.

**Q:** How to short-circuit?  
**A:** Throw an error or have a link return a sentinel flag consumed by a conditional link.

**Q:** Support for cancellation?  
**A:** Use AbortController; middleware can check `signal.aborted`.

**Q:** Can middleware change data?  
**A:** It can insert but keep business transformations in links.

---
## 16. Glossary
- **Link**: Async transformer.
- **Chain**: Ordered execution pipeline.
- **Context**: Immutable key-value data store with type evolution helpers.
- **Middleware**: Optional observers (before/after/error).
- **Type Evolution**: Safe widening via `insertAs`.

---
## 17. TL;DR
```text
Install: npm i @codeuchain/javascript
Model: Links + Chain + Context + Middleware + Type Evolution
Types: Start any → add interfaces + insertAs for evolution
Testing: Per-link tests + chained scenarios
Observability: Middleware logging/metrics/tracing
Performance: Pure functions, avoid giant blobs & over-logging
Errors: Central catch + retry decorator
Adoption: Mixed JS + TS gradual tightening
Avoid: hidden state, silent catches, secret leakage
```

---
### Support & Resources
- Issues: https://github.com/codeuchain/codeuchain/issues
- Discussions: https://github.com/codeuchain/codeuchain/discussions
- Examples: `packages/javascript/examples/`
- License: Apache 2.0

---
© 2025 Orchestrate LLC (Joshua @orchestrate.solutions) – Apache 2.0