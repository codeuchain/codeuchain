
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>go: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/codeuchain/codeuchain/go/codeuchain.go (97.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package codeuchain provides a modular framework for chaining processing links
// with middleware support, embracing the agape philosophy of selfless design.
package codeuchain

import (
        "context"
)

// Context holds data tenderly, immutable by default for safety, mutable for flexibility.
// With agape compassion, it embraces Go's map-based approach with JSON marshaling.
// Enhanced with generic typing for type-safe workflows.
type Context[T any] struct {
        data map[string]interface{}
}

// NewContext creates a new context with initial data
func NewContext[T any](data map[string]interface{}) *Context[T] <span class="cov9" title="56">{
        if data == nil </span><span class="cov3" title="3">{
                data = make(map[string]interface{})
        }</span>
        <span class="cov9" title="56">return &amp;Context[T]{data: data}</span>
}

// Get returns the value for the given key, forgiving absence with nil
func (c *Context[T]) Get(key string) interface{} <span class="cov10" title="86">{
        return c.data[key]
}</span>

// Insert returns a fresh context with the addition, maintaining immutability
func (c *Context[T]) Insert(key string, value interface{}) *Context[T] <span class="cov8" title="37">{
        newData := make(map[string]interface{})
        for k, v := range c.data </span><span class="cov8" title="36">{
                newData[k] = v
        }</span>
        <span class="cov8" title="37">newData[key] = value
        return &amp;Context[T]{data: newData}</span>
}

// InsertAs returns a fresh context with type evolution, allowing clean type transformations
func (c *Context[T]) InsertAs(key string, value interface{}) *Context[any] <span class="cov5" title="8">{
        newData := make(map[string]interface{})
        for k, v := range c.data </span><span class="cov5" title="9">{
                newData[k] = v
        }</span>
        <span class="cov5" title="8">newData[key] = value
        return &amp;Context[any]{data: newData}</span>
}

// Merge combines contexts, favoring the other with compassion
func (c *Context[T]) Merge(other *Context[T]) *Context[T] <span class="cov3" title="3">{
        newData := make(map[string]interface{})
        for k, v := range c.data </span><span class="cov4" title="5">{
                newData[k] = v
        }</span>
        <span class="cov3" title="3">for k, v := range other.data </span><span class="cov4" title="5">{
                newData[k] = v
        }</span>
        <span class="cov3" title="3">return &amp;Context[T]{data: newData}</span>
}

// ToMap returns a copy of the internal data
func (c *Context[T]) ToMap() map[string]interface{} <span class="cov1" title="1">{
        result := make(map[string]interface{})
        for k, v := range c.data </span><span class="cov3" title="3">{
                result[k] = v
        }</span>
        <span class="cov1" title="1">return result</span>
}

// MutableContext provides mutable access for performance-critical sections
type MutableContext struct {
        data map[string]interface{}
}

// NewMutableContext creates a new mutable context
func NewMutableContext() *MutableContext <span class="cov1" title="1">{
        return &amp;MutableContext{data: make(map[string]interface{})}
}</span>

// Get returns the value for the given key
func (mc *MutableContext) Get(key string) interface{} <span class="cov1" title="1">{
        return mc.data[key]
}</span>

// Set changes the value in place
func (mc *MutableContext) Set(key string, value interface{}) <span class="cov1" title="1">{
        mc.data[key] = value
}</span>

// ToImmutable returns a fresh immutable copy
func (mc *MutableContext) ToImmutable() *Context[any] <span class="cov1" title="1">{
        return NewContext[any](mc.data)
}</span>

// Link defines the selfless processor interface
type Link[TInput any, TOutput any] interface {
        // Call processes the context and returns a transformed context
        Call(ctx context.Context, c *Context[TInput]) (*Context[TOutput], error)
}

// Middleware defines optional enhancement hooks for processing links.
// All methods have default no-op implementations - override only what you need.
type Middleware[TInput any, TOutput any] interface {
        // Before is called before link execution (optional - defaults to no-op)
        Before(ctx context.Context, link Link[TInput, TOutput], c *Context[TInput]) error
        // After is called after successful link execution (optional - defaults to no-op)
        After(ctx context.Context, link Link[TInput, TOutput], c *Context[TOutput]) error
        // OnError is called when link execution fails (optional - defaults to no-op)
        OnError(ctx context.Context, link Link[TInput, TOutput], err error, c *Context[TInput]) error
}

// NopMiddleware provides no-op implementations for all middleware methods.
// This is the default middleware that does nothing - perfect for embedding or as a base.
var NopMiddleware = &amp;nopMiddleware{}

type nopMiddleware struct{}

func (n *nopMiddleware) Before(ctx context.Context, link Link[any, any], c *Context[any]) error <span class="cov4" title="7">{
        return nil // No-op
}</span>

func (n *nopMiddleware) After(ctx context.Context, link Link[any, any], c *Context[any]) error <span class="cov3" title="3">{
        return nil // No-op
}</span>

func (n *nopMiddleware) OnError(ctx context.Context, link Link[any, any], err error, c *Context[any]) error <span class="cov2" title="2">{
        return nil // No-op
}</span>

// Connection represents a conditional flow between links
type Connection[T any] struct {
        Source      string
        Target      string
        Condition   func(*Context[T]) bool
}

// Chain orchestrates link execution with middleware
type Chain struct {
        links       map[string]Link[any, any]
        linkOrder   []string // Maintain insertion order
        connections []Connection[any]
        middlewares []Middleware[any, any]
}

// NewChain creates a new empty chain
func NewChain() *Chain <span class="cov6" title="19">{
        return &amp;Chain{
                links:       make(map[string]Link[any, any]),
                linkOrder:   make([]string, 0),
                connections: make([]Connection[any], 0),
                middlewares: make([]Middleware[any, any], 0),
        }
}</span>

// AddLink stores a link with the given name
func (ch *Chain) AddLink(name string, link Link[any, any]) <span class="cov7" title="20">{
        if _, exists := ch.links[name]; !exists </span><span class="cov7" title="20">{
                ch.linkOrder = append(ch.linkOrder, name)
        }</span>
        <span class="cov7" title="20">ch.links[name] = link</span>
}

// Connect adds a conditional connection between links
func (ch *Chain) Connect(source, target string, condition func(*Context[any]) bool) <span class="cov1" title="1">{
        ch.connections = append(ch.connections, Connection[any]{
                Source:    source,
                Target:    target,
                Condition: condition,
        })
}</span>

// UseMiddleware attaches middleware to the chain
func (ch *Chain) UseMiddleware(mw Middleware[any, any]) <span class="cov6" title="13">{
        ch.middlewares = append(ch.middlewares, mw)
}</span>

// Run executes the chain with the given context
func (ch *Chain) Run(ctx context.Context, initialCtx *Context[any]) (*Context[any], error) <span class="cov6" title="19">{
        currentCtx := initialCtx

        // Execute before hooks
        for _, mw := range ch.middlewares </span><span class="cov6" title="13">{
                if err := mw.Before(ctx, nil, currentCtx); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }

        // Simple linear execution for now
        <span class="cov6" title="18">for _, name := range ch.linkOrder </span><span class="cov6" title="19">{
                link := ch.links[name]
                // Before each link
                for _, mw := range ch.middlewares </span><span class="cov5" title="11">{
                        if err := mw.Before(ctx, link, currentCtx); err != nil </span><span class="cov1" title="1">{
                                // On error
                                for _, mwErr := range ch.middlewares </span><span class="cov1" title="1">{
                                        _ = mwErr.OnError(ctx, link, err, currentCtx)
                                }</span>
                                <span class="cov1" title="1">return nil, err</span>
                        }
                }

                // Execute link
                <span class="cov6" title="18">resultCtx, err := link.Call(ctx, currentCtx)
                if err != nil </span><span class="cov3" title="3">{
                        // On error - call all middlewares but don't suppress by default
                        for _, mwErr := range ch.middlewares </span><span class="cov3" title="3">{
                                _ = mwErr.OnError(ctx, link, err, currentCtx)
                        }</span>
                        <span class="cov3" title="3">return nil, err</span>
                }
                <span class="cov6" title="15">currentCtx = resultCtx

                // After each link
                for _, mw := range ch.middlewares </span><span class="cov4" title="7">{
                        if err := mw.After(ctx, link, currentCtx); err != nil </span><span class="cov2" title="2">{
                                return nil, err
                        }</span>
                }
        }

        // Final after hooks
        <span class="cov6" title="12">for _, mw := range ch.middlewares </span><span class="cov4" title="6">{
                if err := mw.After(ctx, nil, currentCtx); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov6" title="12">return currentCtx, nil</span>
}

// ErrorHandlingMixin provides compassionate error routing
type ErrorHandlingMixin struct {
        ErrorConnections []ErrorConnection
}

// ErrorConnection represents an error routing rule
type ErrorConnection struct {
        Source    string
        Handler   string
        Condition func(error) bool
}

// NewErrorHandlingMixin creates a new error handling mixin
func NewErrorHandlingMixin() *ErrorHandlingMixin <span class="cov3" title="4">{
        return &amp;ErrorHandlingMixin{
                ErrorConnections: make([]ErrorConnection, 0),
        }
}</span>

// OnError adds an error routing rule
func (ehm *ErrorHandlingMixin) OnError(source, handler string, condition func(error) bool) <span class="cov3" title="4">{
        ehm.ErrorConnections = append(ehm.ErrorConnections, ErrorConnection{
                Source:    source,
                Handler:   handler,
                Condition: condition,
        })
}</span>

// HandleError finds and calls the appropriate error handler
func (ehm *ErrorHandlingMixin) HandleError(linkName string, err error, ctx *Context[any], links map[string]Link[any, any]) (*Context[any], error) <span class="cov3" title="4">{
        for _, conn := range ehm.ErrorConnections </span><span class="cov3" title="4">{
                if conn.Source == linkName &amp;&amp; conn.Condition(err) </span><span class="cov3" title="3">{
                        if handler, exists := links[conn.Handler]; exists </span><span class="cov2" title="2">{
                                ctxWithError := ctx.Insert("error", err.Error())
                                return handler.Call(context.Background(), ctxWithError)
                        }</span>
                }
        }
        <span class="cov2" title="2">return nil, nil</span> // No handler found
}

// RetryLink provides forgiveness through retries
type RetryLink struct {
        Inner     Link[any, any]
        MaxRetries int
}

// NewRetryLink creates a new retry link
func NewRetryLink(inner Link[any, any], maxRetries int) *RetryLink <span class="cov4" title="7">{
        return &amp;RetryLink{
                Inner:      inner,
                MaxRetries: maxRetries,
        }
}</span>

// Call implements the Link interface with retry logic
func (rl *RetryLink) Call(ctx context.Context, c *Context[any]) (*Context[any], error) <span class="cov4" title="7">{
        var lastErr error

        for attempt := 0; attempt &lt;= rl.MaxRetries; attempt++ </span><span class="cov6" title="14">{
                result, err := rl.Inner.Call(ctx, c)
                if err == nil </span><span class="cov3" title="4">{
                        return result, nil
                }</span>
                <span class="cov5" title="10">lastErr = err

                if attempt == rl.MaxRetries </span><span class="cov3" title="3">{
                        return c.Insert("error", lastErr.Error()), lastErr
                }</span>
        }

        <span class="cov0" title="0">return c.Insert("error", "Max retries exceeded"), lastErr</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
