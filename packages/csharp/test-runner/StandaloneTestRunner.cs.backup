using System;using System;

using System.Collections.Generic;using System.Collections.Generic;

using System.Collections.Immutable;using System.Collections.Immutable;

using System.Diagnostics;using System.Diagnostics;

using System.Threading.Tasks;using System.Threading.Tasks;



/// <summary>/// <summary>

/// Standalone Comprehensive Test Suite for CodeUChain C# Implementation/// Standalone Comprehensive Test Suite for CodeUChain C# Implementation

/// Includes all source code directly to avoid build system issues./// Includes all source code directly to avoid build system issues.

/// Provides full code coverage and verbose testing./// Provides full code coverage and verbose testing.

/// </summary>/// </summary>



// ===== INLINE SOURCE CODE =====// ===== INLINE SOURCE CODE =====



/// <summary>/// <summary>

/// Context: The Immutable Data Carrier/// Context: The Immutable Data Carrier

/// Carries data through the processing chain in an immutable manner./// Carries data through the processing chain in an immutable manner.

/// </summary>/// </summary>

public class Contextpublic class Context

{{

    private readonly ImmutableDictionary<string, object> _data;    private readonly ImmutableDictionary<string, object> _data;



    private Context(ImmutableDictionary<string, object> data)    private Context(ImmutableDictionary<string, object> data)

    {    {

        _data = data;        _data = data;

    }    }



    /// <summary>    /// <summary>

    /// Creates a new empty context.    /// Creates a new empty context.

    /// </summary>    /// </summary>

    public static Context Create()    public static Context Create()

    {    {

        return new Context(ImmutableDictionary<string, object>.Empty);        return new Context(ImmutableDictionary<string, object>.Empty);

    }    }



    /// <summary>    /// <summary>

    /// Creates a new context with initial data.    /// Creates a new context with initial data.

    /// </summary>    /// </summary>

    public static Context Create(IDictionary<string, object> data)    public static Context Create(IDictionary<string, object> data)

    {    {

        return new Context(data.ToImmutableDictionary());        return new Context(data.ToImmutableDictionary());

    }    }



    /// <summary>    /// <summary>

    /// Retrieves a value from the context.    /// Retrieves a value from the context.

    /// </summary>    /// </summary>

    public object? Get(string key)    public object? Get(string key)

    {    {

        return _data.TryGetValue(key, out var value) ? value : null;        return _data.TryGetValue(key, out var value) ? value : null;

    }    }



    /// <summary>    /// <summary>

    /// Retrieves a typed value from the context.    /// Retrieves a typed value from the context.

    /// </summary>    /// </summary>

    public T? Get<T>(string key)    public T? Get<T>(string key)

    {    {

        return _data.TryGetValue(key, out var value) && value is T typedValue ? typedValue : default;        return _data.TryGetValue(key, out var value) && value is T typedValue ? typedValue : default;

    }    }



    /// <summary>    /// <summary>

    /// Checks if the context contains a key.    /// Checks if the context contains a key.

    /// </summary>    /// </summary>

    public bool ContainsKey(string key)    public bool ContainsKey(string key)

    {    {

        return _data.ContainsKey(key);        return _data.ContainsKey(key);

    }    }



    /// <summary>    /// <summary>

    /// Returns a new context with the specified key-value pair inserted.    /// Returns a new context with the specified key-value pair inserted.

    /// </summary>    /// </summary>

    public Context Insert(string key, object value)    public Context Insert(string key, object value)

    {    {

        return new Context(_data.SetItem(key, value));        return new Context(_data.SetItem(key, value));

    }    }



    /// <summary>    /// <summary>

    /// Type Evolution: Insert with type transformation    /// Type Evolution: Insert with type transformation

    /// Returns a new context with the specified key-value pair inserted, enabling clean type evolution.    /// Returns a new context with the specified key-value pair inserted, enabling clean type evolution.

    /// This method allows transforming the context's type without explicit casting.    /// This method allows transforming the context's type without explicit casting.

    /// </summary>    /// </summary>

    public Context InsertAs(string key, object value)    public Context InsertAs(string key, object value)

    {    {

        return new Context(_data.SetItem(key, value));        return new Context(_data.SetItem(key, value));

    }    }



    /// <summary>    /// <summary>

    /// Returns a new context with the specified key removed.    /// Returns a new context with the specified key removed.

    /// </summary>    /// </summary>

    public Context Remove(string key)    public Context Remove(string key)

    {    {

        return new Context(_data.Remove(key));        return new Context(_data.Remove(key));

    }    }



    /// <summary>    /// <summary>

    /// Returns all keys in the context.    /// Returns all keys in the context.

    /// </summary>    /// </summary>

    public IEnumerable<string> Keys => _data.Keys;    public IEnumerable<string> Keys => _data.Keys;



    /// <summary>    /// <summary>

    /// Returns all values in the context.    /// Returns all values in the context.

    /// </summary>    /// </summary>

    public IEnumerable<object> Values => _data.Values;    public IEnumerable<object> Values => _data.Values;



    /// <summary>    /// <summary>

    /// Returns the number of items in the context.    /// Returns the number of items in the context.

    /// </summary>    /// </summary>

    public int Count => _data.Count;    public int Count => _data.Count;



    /// <summary>    /// <summary>

    /// Returns a string representation of the context.    /// Returns a string representation of the context.

    /// </summary>    /// </summary>

    public override string ToString()    public override string ToString()

    {    {

        return $"Context({string.Join(", ", _data.Select(kv => $"{kv.Key}: {kv.Value}"))})";        return $"Context({string.Join(", ", _data.Select(kv => $"{kv.Key}: {kv.Value}"))})";

    }    }

}}



/// <summary>/// <summary>

/// Generic Context: Opt-in Type Safety/// Generic Context: Opt-in Type Safety

/// Strongly-typed version of Context for static type checking while maintaining runtime flexibility./// Strongly-typed version of Context for static type checking while maintaining runtime flexibility.

/// Supports clean type evolution through InsertAs<U>() method./// Supports clean type evolution through InsertAs<U>() method.

/// Follows the universal pattern across all CodeUChain languages./// Follows the universal pattern across all CodeUChain languages.

/// </summary>/// </summary>

public class Context<T> where T : classpublic class Context<T> where T : class

{{

    private readonly ImmutableDictionary<string, object> _data;    private readonly ImmutableDictionary<string, object> _data;



    private Context(ImmutableDictionary<string, object> data)    private Context(ImmutableDictionary<string, object> data)

    {    {

        _data = data;        _data = data;

    }    }



    /// <summary>    /// <summary>

    /// Creates a new empty generic context.    /// Creates a new empty generic context.

    /// </summary>    /// </summary>

    public static Context<T> Create()    public static Context<T> Create()

    {    {

        return new Context<T>(ImmutableDictionary<string, object>.Empty);        return new Context<T>(ImmutableDictionary<string, object>.Empty);

    }    }



    /// <summary>    /// <summary>

    /// Creates a new generic context with initial data.    /// Creates a new generic context with initial data.

    /// </summary>    /// </summary>

    public static Context<T> Create(IDictionary<string, object> data)    public static Context<T> Create(IDictionary<string, object> data)

    {    {

        return new Context<T>(data.ToImmutableDictionary());        return new Context<T>(data.ToImmutableDictionary());

    }    }



    /// <summary>    /// <summary>

    /// Retrieves a typed value from the context.    /// Retrieves a typed value from the context.

    /// </summary>    /// </summary>

    public T? Get(string key)    public T? Get(string key)

    {    {

        return _data.TryGetValue(key, out var value) && value is T typedValue ? typedValue : default;        return _data.TryGetValue(key, out var value) && value is T typedValue ? typedValue : default;

    }    }



    /// <summary>    /// <summary>

    /// Retrieves a value of any type from the context.    /// Retrieves a value of any type from the context.

    /// </summary>    /// </summary>

    public object? GetAny(string key)    public object? GetAny(string key)

    {    {

        return _data.TryGetValue(key, out var value) ? value : null;        return _data.TryGetValue(key, out var value) ? value : null;

    }    }



    /// <summary>    /// <summary>

    /// Checks if the context contains a key.    /// Checks if the context contains a key.

    /// </summary>    /// </summary>

    public bool ContainsKey(string key)    public bool ContainsKey(string key)

    {    {

        return _data.ContainsKey(key);        return _data.ContainsKey(key);

    }    }



    /// <summary>    /// <summary>

    /// Type Preservation: Insert that maintains current type T    /// Type Preservation: Insert that maintains current type T

    /// Returns a new context with the specified key-value pair inserted.    /// Returns a new context with the specified key-value pair inserted.

    /// </summary>    /// </summary>

    public Context<T> Insert(string key, object value)    public Context<T> Insert(string key, object value)

    {    {

        return new Context<T>(_data.SetItem(key, value));        return new Context<T>(_data.SetItem(key, value));

    }    }



    /// <summary>    /// <summary>

    /// Type Evolution: Insert with type transformation    /// Type Evolution: Insert with type transformation

    /// Returns a new context with the specified key-value pair inserted, enabling clean type evolution.    /// Returns a new context with the specified key-value pair inserted, enabling clean type evolution.

    /// This method allows transforming the context's type to U without explicit casting.    /// This method allows transforming the context's type to U without explicit casting.

    /// </summary>    /// </summary>

    public Context<U> InsertAs<U>(string key, object value) where U : class    public Context<U> InsertAs<U>(string key, object value) where U : class

    {    {

        return new Context<U>(_data.SetItem(key, value));        return new Context<U>(_data.SetItem(key, value));

    }    }



    /// <summary>    /// <summary>

    /// Returns a new context with the specified key removed.    /// Returns a new context with the specified key removed.

    /// </summary>    /// </summary>

    public Context<T> Remove(string key)    public Context<T> Remove(string key)

    {    {

        return new Context<T>(_data.Remove(key));        return new Context<T>(_data.Remove(key));

    }    }



    /// <summary>    /// <summary>

    /// Returns all keys in the context.    /// Returns all keys in the context.

    /// </summary>    /// </summary>

    public IEnumerable<string> Keys => _data.Keys;    public IEnumerable<string> Keys => _data.Keys;



    /// <summary>    /// <summary>

    /// Returns all values in the context.    /// Returns all values in the context.

    /// </summary>    /// </summary>

    public IEnumerable<object> Values => _data.Values;    public IEnumerable<object> Values => _data.Values;



    /// <summary>    /// <summary>

    /// Returns the number of items in the context.    /// Returns the number of items in the context.

    /// </summary>    /// </summary>

    public int Count => _data.Count;    public int Count => _data.Count;



    /// <summary>    /// <summary>

    /// Returns a string representation of the generic context.    /// Returns a string representation of the generic context.

    /// </summary>    /// </summary>

    public override string ToString()    public override string ToString()

    {    {

        return $"Context<{typeof(T).Name}>({string.Join(", ", _data.Select(kv => $"{kv.Key}: {kv.Value}"))})";        return $"Context<{typeof(T).Name}>({string.Join(", ", _data.Select(kv => $"{kv.Key}: {kv.Value}"))})";

    }    }

}}



/// <summary>/// <summary>

/// Link: The Processing Unit Interface/// Link: The Processing Unit Interface

/// Unified interface that handles both sync and async operations automatically./// Unified interface that handles both sync and async operations automatically.

/// </summary>/// </summary>

public interface ILinkpublic interface ILink

{{

    /// <summary>    /// <summary>

    /// Processes the context and returns a new context.    /// Processes the context and returns a new context.

    /// Can be implemented as sync or async - the chain handles both automatically.    /// Can be implemented as sync or async - the chain handles both automatically.

    /// </summary>    /// </summary>

    /// <param name="context">The input context</param>    /// <param name="context">The input context</param>

    /// <returns>The processed context</returns>    /// <returns>The processed context</returns>

    ValueTask<Context> ProcessAsync(Context context);    ValueTask<Context> ProcessAsync(Context context);

}}



/// <summary>/// <summary>

/// Generic Link interface for context-based processing./// Generic Link interface for context-based processing.

/// Follows the universal Link[Input, Output] pattern across all CodeUChain languages./// Follows the universal Link[Input, Output] pattern across all CodeUChain languages.

/// </summary>/// </summary>

public interface IContextLink<TInput, TOutput>public interface IContextLink<TInput, TOutput>

    where TInput : class    where TInput : class

    where TOutput : class    where TOutput : class

{{

    Task<Context<TOutput>> CallAsync(Context<TInput> context);    Task<Context<TOutput>> CallAsync(Context<TInput> context);

}}



/// <summary>/// <summary>

/// Middleware: The Chain Enhancement Interface/// Middleware: The Chain Enhancement Interface

/// Provides hooks for intercepting and modifying chain execution./// Provides hooks for intercepting and modifying chain execution.

/// Unified middleware that handles both sync and async operations./// Unified middleware that handles both sync and async operations.

/// </summary>/// </summary>

public interface IMiddlewarepublic interface IMiddleware

{{

    /// <summary>    /// <summary>

    /// Called before a link is executed.    /// Called before a link is executed.

    /// </summary>    /// </summary>

    ValueTask<Context> BeforeAsync(ILink? link, Context context);    ValueTask<Context> BeforeAsync(ILink? link, Context context);



    /// <summary>    /// <summary>

    /// Called after a link is executed successfully.    /// Called after a link is executed successfully.

    /// </summary>    /// </summary>

    ValueTask<Context> AfterAsync(ILink? link, Context context);    ValueTask<Context> AfterAsync(ILink? link, Context context);



    /// <summary>    /// <summary>

    /// Called when a link throws an exception.    /// Called when a link throws an exception.

    /// </summary>    /// </summary>

    ValueTask<Context> OnErrorAsync(ILink? link, Exception exception, Context context);    ValueTask<Context> OnErrorAsync(ILink? link, Exception exception, Context context);

}}



/// <summary>/// <summary>

/// Generic Middleware interface./// Generic Middleware interface.

/// Simplified for type-evolving chains - middleware operates on the current context type./// Simplified for type-evolving chains - middleware operates on the current context type.

/// </summary>/// </summary>

public interface IMiddleware<T>public interface IMiddleware<T>

    where T : class    where T : class

{{

    Task<Context<T>> BeforeAsync(IContextLink<T, T>? link, Context<T> context);    Task<Context<T>> BeforeAsync(IContextLink<T, T>? link, Context<T> context);

    Task<Context<T>> AfterAsync(IContextLink<T, T>? link, Context<T> context);    Task<Context<T>> AfterAsync(IContextLink<T, T>? link, Context<T> context);

    Task<Context<T>> OnErrorAsync(IContextLink<T, T>? link, Exception exception, Context<T> context);    Task<Context<T>> OnErrorAsync(IContextLink<T, T>? link, Exception exception, Context<T> context);

}}



/// <summary>/// <summary>

/// Chain: The Harmonious Connector/// Chain: The Harmonious Connector

/// Unified implementation that handles both sync and async operations seamlessly./// Unified implementation that handles both sync and async operations seamlessly.

/// </summary>/// </summary>

public class Chainpublic class Chain

{{

    private readonly ImmutableList<KeyValuePair<string, ILink>> _links;    private readonly ImmutableList<KeyValuePair<string, ILink>> _links;

    private readonly ImmutableList<IMiddleware> _middlewares;    private readonly ImmutableList<IMiddleware> _middlewares;



    private Chain(ImmutableList<KeyValuePair<string, ILink>> links, ImmutableList<IMiddleware> middlewares)    private Chain(ImmutableList<KeyValuePair<string, ILink>> links, ImmutableList<IMiddleware> middlewares)

    {    {

        _links = links;        _links = links;

        _middlewares = middlewares;        _middlewares = middlewares;

    }    }



    public Chain()    public Chain()

    {    {

        _links = ImmutableList<KeyValuePair<string, ILink>>.Empty;        _links = ImmutableList<KeyValuePair<string, ILink>>.Empty;

        _middlewares = ImmutableList<IMiddleware>.Empty;        _middlewares = ImmutableList<IMiddleware>.Empty;

    }    }



    /// <summary>    /// <summary>

    /// Adds a link to the chain.    /// Adds a link to the chain.

    /// </summary>    /// </summary>

    public Chain AddLink(string name, ILink link)    public Chain AddLink(string name, ILink link)

    {    {

        return new Chain(_links.Add(new KeyValuePair<string, ILink>(name, link)), _middlewares);        return new Chain(_links.Add(new KeyValuePair<string, ILink>(name, link)), _middlewares);

    }    }



    /// <summary>    /// <summary>

    /// Adds middleware to the chain.    /// Adds middleware to the chain.

    /// </summary>    /// </summary>

    public Chain UseMiddleware(IMiddleware middleware)    public Chain UseMiddleware(IMiddleware middleware)

    {    {

        return new Chain(_links, _middlewares.Add(middleware));        return new Chain(_links, _middlewares.Add(middleware));

    }    }



    /// <summary>    /// <summary>

    /// Executes the chain. Automatically handles sync/async based on the links.    /// Executes the chain. Automatically handles sync/async based on the links.

    /// </summary>    /// </summary>

    public async ValueTask<Context> RunAsync(Context initialContext)    public async ValueTask<Context> RunAsync(Context initialContext)

    {    {

        var currentContext = initialContext;        var currentContext = initialContext;



        // Execute before hooks        // Execute before hooks

        foreach (var middleware in _middlewares)        foreach (var middleware in _middlewares)

        {        {

            try            try

            {            {

                currentContext = await middleware.BeforeAsync(null, currentContext);                currentContext = await middleware.BeforeAsync(null, currentContext);

            }            }

            catch (Exception ex)            catch (Exception ex)

            {            {

                // Handle middleware errors                // Handle middleware errors

                foreach (var errorMiddleware in _middlewares)                foreach (var errorMiddleware in _middlewares)

                {                {

                    try                    try

                    {                    {

                        currentContext = await errorMiddleware.OnErrorAsync(null, ex, currentContext);                        currentContext = await errorMiddleware.OnErrorAsync(null, ex, currentContext);

                    }                    }

                    catch                    catch

                    {                    {

                        // Continue with other error handlers                        // Continue with other error handlers

                    }                    }

                }                }

                throw;                throw;

            }            }

        }        }



        // Execute links        // Execute links

        foreach (var (name, link) in _links)        foreach (var (name, link) in _links)

        {        {

            // Before each link            // Before each link

            foreach (var middleware in _middlewares)            foreach (var middleware in _middlewares)

            {            {

                try                try

                {                {

                    currentContext = await middleware.BeforeAsync(link, currentContext);                    currentContext = await middleware.BeforeAsync(link, currentContext);

                }                }

                catch (Exception ex)                catch (Exception ex)

                {                {

                    // Handle middleware errors                    // Handle middleware errors

                    foreach (var errorMiddleware in _middlewares)                    foreach (var errorMiddleware in _middlewares)

                    {                    {

                        try                        try

                        {                        {

                            currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);                            currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);

                        }                        }

                        catch                        catch

                        {                        {

                            // Continue with other error handlers                            // Continue with other error handlers

                        }                        }

                    }                    }

                    throw;                    throw;

                }                }

            }            }



            // Execute link            // Execute link

            try            try

            {            {

                currentContext = await link.ProcessAsync(currentContext);                currentContext = await link.ProcessAsync(currentContext);

            }            }

            catch (Exception ex)            catch (Exception ex)

            {            {

                // Handle link errors                // Handle link errors

                foreach (var middleware in _middlewares)                foreach (var middleware in _middlewares)

                {                {

                    try                    try

                    {                    {

                        currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);                        currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);

                    }                    }

                    catch                    catch

                    {                    {

                        // Continue with other error handlers                        // Continue with other error handlers

                    }                    }

                }                }

                throw;                throw;

            }            }



            // After each link            // After each link

            foreach (var middleware in _middlewares)            foreach (var middleware in _middlewares)

            {            {

                try                try

                {                {

                    currentContext = await middleware.AfterAsync(link, currentContext);                    currentContext = await middleware.AfterAsync(link, currentContext);

                }                }

                catch (Exception ex)                catch (Exception ex)

                {                {

                    // Handle middleware errors                    // Handle middleware errors

                    foreach (var errorMiddleware in _middlewares)                    foreach (var errorMiddleware in _middlewares)

                    {                    {

                        try                        try

                        {                        {

                            currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);                            currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);

                        }                        }

                        catch                        catch

                        {                        {

                            // Continue with other error handlers                            // Continue with other error handlers

                        }                        }

                    }                    }

                    throw;                    throw;

                }                }

            }            }

        }        }



        // Final after hooks        // Final after hooks

        foreach (var middleware in _middlewares)        foreach (var middleware in _middlewares)

        {        {

            try            try

            {            {

                currentContext = await middleware.AfterAsync(null, currentContext);                currentContext = await middleware.AfterAsync(null, currentContext);

            }            }

            catch (Exception ex)            catch (Exception ex)

            {            {

                // Handle middleware errors                // Handle middleware errors

                foreach (var errorMiddleware in _middlewares)                foreach (var errorMiddleware in _middlewares)

                {                {

                    try                    try

                    {                    {

                        currentContext = await errorMiddleware.OnErrorAsync(null, ex, currentContext);                        currentContext = await errorMiddleware.OnErrorAsync(null, ex, currentContext);

                    }                    }

                    catch                    catch

                    {                    {

                        // Continue with other error handlers                        // Continue with other error handlers

                    }                    }

                }                }

                throw;                throw;

            }            }

        }        }



        return currentContext;        return currentContext;

    }    }



    /// <summary>    /// <summary>

    /// Synchronous execution - blocks if any async operations are present.    /// Synchronous execution - blocks if any async operations are present.

    /// </summary>    /// </summary>

    public Context RunSync(Context initialContext)    public Context RunSync(Context initialContext)

    {    {

        return RunAsync(initialContext).GetAwaiter().GetResult();        return RunAsync(initialContext).GetAwaiter().GetResult();

    }    }

}}



/// <summary>/// <summary>

/// Generic Chain with type safety./// Generic Chain with type safety.

/// Supports the universal Link[Input, Output] pattern for clean type evolution./// Supports the universal Link[Input, Output] pattern for clean type evolution.

/// Note: Middleware is simplified to work with single types for now./// Note: Middleware is simplified to work with single types for now.

/// </summary>/// </summary>

public class Chain<TInput, TOutput>public class Chain<TInput, TOutput>

    where TInput : class    where TInput : class

    where TOutput : class    where TOutput : class

{{

    private readonly ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>> _links;    private readonly ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>> _links;



    private Chain(ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>> links)    private Chain(ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>> links)

    {    {

        _links = links;        _links = links;

    }    }



    public Chain()    public Chain()

    {    {

        _links = ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>>.Empty;        _links = ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>>.Empty;

    }    }



    /// <summary>    /// <summary>

    /// Adds a link to the chain.    /// Adds a link to the chain.

    /// </summary>    /// </summary>

    public Chain<TInput, TOutput> AddLink(string name, IContextLink<TInput, TOutput> link)    public Chain<TInput, TOutput> AddLink(string name, IContextLink<TInput, TOutput> link)

    {    {

        return new Chain<TInput, TOutput>(_links.Add(new KeyValuePair<string, IContextLink<TInput, TOutput>>(name, link)));        return new Chain<TInput, TOutput>(_links.Add(new KeyValuePair<string, IContextLink<TInput, TOutput>>(name, link)));

    }    }



    /// <summary>    /// <summary>

    /// Executes the chain with the given context.    /// Executes the chain with the given context.

    /// </summary>    /// </summary>

    public async Task<Context<TOutput>> RunAsync(Context<TInput> initialContext)    public async Task<Context<TOutput>> RunAsync(Context<TInput> initialContext)

    {    {

        // For a chain with type evolution, we need to handle the type transformation properly        // For a chain with type evolution, we need to handle the type transformation properly

        // This is a simplified implementation - in practice, you'd want a more sophisticated approach        // This is a simplified implementation - in practice, you'd want a more sophisticated approach



        Context<TInput> currentInputContext = initialContext;        Context<TInput> currentInputContext = initialContext;

        Context<TOutput> currentOutputContext = default!;        Context<TOutput> currentOutputContext = default!;



        // Execute links with type evolution        // Execute links with type evolution

        foreach (var (name, link) in _links)        foreach (var (name, link) in _links)

        {        {

            try            try

            {            {

                currentOutputContext = await link.CallAsync(currentInputContext);                currentOutputContext = await link.CallAsync(currentInputContext);

                // For subsequent links, we need to adapt the context type                // For subsequent links, we need to adapt the context type

                // This is a limitation of the current simplified implementation                // This is a limitation of the current simplified implementation

                currentInputContext = currentOutputContext.InsertAs<TInput>("__temp", new object()).Remove("__temp");                currentInputContext = currentOutputContext.InsertAs<TInput>("__temp", new object()).Remove("__temp");

            }            }

            catch (Exception)            catch (Exception)

            {            {

                // For now, rethrow exceptions - middleware can be added later                // For now, rethrow exceptions - middleware can be added later

                throw;                throw;

            }            }

        }        }



        return currentOutputContext;        return currentOutputContext;

    }    }

}}



// ===== TEST LINK IMPLEMENTATIONS =====// ===== TEST LINK IMPLEMENTATIONS =====



public class StringToObjectLink : IContextLink<string, object>public class StringToObjectLink : IContextLink<string, object>

{{

    public async Task<Context<object>> CallAsync(Context<string> context)    public async Task<Context<object>> CallAsync(Context<string> context)

    {    {

        var value = context.Get("value");        var value = context.Get("value");

        return Context<object>.Create(new Dictionary<string, object>        return Context<object>.Create(new Dictionary<string, object>

        {        {

            ["result"] = value            ["result"] = value

        });        });

    }    }

}}



public class DoubleValueLink : IContextLink<object, object>public class DoubleValueLink : IContextLink<object, object>

{{

    public async Task<Context<object>> CallAsync(Context<object> context)    public async Task<Context<object>> CallAsync(Context<object> context)

    {    {

        var valueStr = context.GetAny("result")?.ToString() ?? context.GetAny("value")?.ToString() ?? "0";        var valueStr = context.GetAny("result")?.ToString() ?? context.GetAny("value")?.ToString() ?? "0";

        if (int.TryParse(valueStr, out int value))        if (int.TryParse(valueStr, out int value))

        {        {

            return Context<object>.Create(new Dictionary<string, object>            return Context<object>.Create(new Dictionary<string, object>

            {            {

                ["final"] = (value * 2).ToString()                ["final"] = (value * 2).ToString()

            });            });

        }        }

        return context;        return context;

    }    }

}}



public class DataProcessorLink : IContextLink<object, object>public class DataProcessorLink : IContextLink<object, object>

{{

    public async Task<Context<object>> CallAsync(Context<object> context)    public async Task<Context<object>> CallAsync(Context<object> context)

    {    {

        var data = context.GetAny("data")?.ToString() ?? "";        var data = context.GetAny("data")?.ToString() ?? "";

        var multiplier = (int?)context.GetAny("multiplier") ?? 1;        var multiplier = (int?)context.GetAny("multiplier") ?? 1;



        return Context<object>.Create(new Dictionary<string, object>        return Context<object>.Create(new Dictionary<string, object>

        {        {

            ["processed"] = data.ToUpper(),            ["processed"] = data.ToUpper(),

            ["calculated"] = multiplier * 2            ["calculated"] = multiplier * 2

        });        });

    }    }

}}



public class UntypedProcessorLink : IContextLink<object, object>public class UntypedProcessorLink : IContextLink<object, object>

{{

    public async Task<Context<object>> CallAsync(Context<object> context)    public async Task<Context<object>> CallAsync(Context<object> context)

    {    {

        return context.Insert("untyped", "processed");        return context.Insert("untyped", "processed");

    }    }

}}



public class TypedProcessorLink : IContextLink<object, object>public class TypedProcessorLink : IContextLink<object, object>

{{

    public async Task<Context<object>> CallAsync(Context<object> context)    public async Task<Context<object>> CallAsync(Context<object> context)

    {    {

        return context.Insert("typed", "processed");        return context.Insert("typed", "processed");

    }    }

}}



public class LegacyProcessor : ILinkpublic class LegacyProcessor : ILink

{{

    public ValueTask<Context> ProcessAsync(Context context)    public ValueTask<Context> ProcessAsync(Context context)

    {    {

        var input = context.Get("input")?.ToString() ?? "";        var input = context.Get("input")?.ToString() ?? "";

        return ValueTask.FromResult(context.Insert("output", input.ToUpper()));        return ValueTask.FromResult(context.Insert("output", input.ToUpper()));

    }    }

}}



public class LoggingMiddleware : IMiddlewarepublic class LoggingMiddleware : IMiddleware

{{

    public ValueTask<Context> BeforeAsync(ILink? link, Context context)    public ValueTask<Context> BeforeAsync(ILink? link, Context context)

    {    {

        Console.WriteLine($"[LOG] Starting: {link?.GetType().Name ?? "Chain"}");        Console.WriteLine($"[LOG] Starting: {link?.GetType().Name ?? "Chain"}");

        return ValueTask.FromResult(context);        return ValueTask.FromResult(context);

    }    }



    public ValueTask<Context> AfterAsync(ILink? link, Context context)    public ValueTask<Context> AfterAsync(ILink? link, Context context)

    {    {

        Console.WriteLine($"[LOG] Completed: {link?.GetType().Name ?? "Chain"}");        Console.WriteLine($"[LOG] Completed: {link?.GetType().Name ?? "Chain"}");

        return ValueTask.FromResult(context);        return ValueTask.FromResult(context);

    }    }



    public ValueTask<Context> OnErrorAsync(ILink? link, Exception exception, Context context)    public ValueTask<Context> OnErrorAsync(ILink? link, Exception exception, Context context)

    {    {

        Console.WriteLine($"[LOG] Error in {link?.GetType().Name ?? "Chain"}: {exception.Message}");        Console.WriteLine($"[LOG] Error in {link?.GetType().Name ?? "Chain"}: {exception.Message}");

        return ValueTask.FromResult(context);        return ValueTask.FromResult(context);

    }    }

}}



public class ErrorLink : IContextLink<object, object>public class ErrorLink : IContextLink<object, object>

{{

    public async Task<Context<object>> CallAsync(Context<object> context)    public async Task<Context<object>> CallAsync(Context<object> context)

    {    {

        if (context.GetAny("trigger")?.ToString() == "error")        if (context.GetAny("trigger")?.ToString() == "error")

            throw new InvalidOperationException("Test error");            throw new InvalidOperationException("Test error");



        return context;        return context;

    }    }

}}



public class PerformanceLink : IContextLink<object, object>public class PerformanceLink : IContextLink<object, object>

{{

    public async Task<Context<object>> CallAsync(Context<object> context)    public async Task<Context<object>> CallAsync(Context<object> context)

    {    {

        var iterations = (int?)context.GetAny("iterations") ?? 10;        var iterations = (int?)context.GetAny("iterations") ?? 10;

        var total = (int?)context.GetAny("total") ?? 0;        var total = (int?)context.GetAny("total") ?? 0;



        // Simulate some processing        // Simulate some processing

        for (int i = 0; i < iterations; i++)        for (int i = 0; i < iterations; i++)

        {        {

            total += 1;            total += 1;

            await Task.Delay(1); // Small delay to simulate work            await Task.Delay(1); // Small delay to simulate work

        }        }



        return Context<object>.Create(new Dictionary<string, object>        return Context<object>.Create(new Dictionary<string, object>

        {        {

            ["total"] = total.ToString()            ["total"] = total.ToString()

        });        });

    }    }

}}



public class ObjectToStringLink : IContextLink<object, object>public class ObjectToStringLink : IContextLink<object, object>

{{

    public async Task<Context<object>> CallAsync(Context<object> context)    public async Task<Context<object>> CallAsync(Context<object> context)

    {    {

        var value = context.GetAny("value")?.ToString() ?? "0";        var value = context.GetAny("value")?.ToString() ?? "0";

        return Context<object>.Create(new Dictionary<string, object>        return Context<object>.Create(new Dictionary<string, object>

        {        {

            ["string"] = value            ["string"] = value

        });        });

    }    }

}}



public class NestedChainLink : IContextLink<object, object>public class NestedChainLink : IContextLink<object, object>

{{

    private readonly Chain<object, object> _innerChain;    private readonly Chain<object, object> _innerChain;



    public NestedChainLink(Chain<object, object> innerChain)    public NestedChainLink(Chain<object, object> innerChain)

    {    {

        _innerChain = innerChain;        _innerChain = innerChain;

    }    }



    public async Task<Context<object>> CallAsync(Context<object> context)    public async Task<Context<object>> CallAsync(Context<object> context)

    {    {

        return await _innerChain.RunAsync(context);        return await _innerChain.RunAsync(context);

    }    }

}}



public class SimpleLink : ILinkpublic class SimpleLink : ILink

{{

    public ValueTask<Context> ProcessAsync(Context context)    public ValueTask<Context> ProcessAsync(Context context)

    {    {

        var input = context.Get("input")?.ToString() ?? "";        var input = context.Get("input")?.ToString() ?? "";

        return ValueTask.FromResult(context.Insert("processed", input.ToUpper()));        return ValueTask.FromResult(context.Insert("processed", input.ToUpper()));

    }    }

}}



public class TimingMiddleware : IMiddlewarepublic class TimingMiddleware : IMiddleware

{{

    public ValueTask<Context> BeforeAsync(ILink? link, Context context)    public ValueTask<Context> BeforeAsync(ILink? link, Context context)

    {    {

        return ValueTask.FromResult(context.Insert("start", DateTime.Now));        return ValueTask.FromResult(context.Insert("start", DateTime.Now));

    }    }



    public ValueTask<Context> AfterAsync(ILink? link, Context context)    public ValueTask<Context> AfterAsync(ILink? link, Context context)

    {    {

        var start = (DateTime?)context.Get("start");        var start = (DateTime?)context.Get("start");

        if (start.HasValue)        if (start.HasValue)

        {        {

            var duration = DateTime.Now - start.Value;            var duration = DateTime.Now - start.Value;

            return ValueTask.FromResult(context.Insert("duration", duration.TotalMilliseconds));            return ValueTask.FromResult(context.Insert("duration", duration.TotalMilliseconds));

        }        }

        return ValueTask.FromResult(context);        return ValueTask.FromResult(context);

    }    }



    public ValueTask<Context> OnErrorAsync(ILink? link, Exception exception, Context context)    public ValueTask<Context> OnErrorAsync(ILink? link, Exception exception, Context context)

    {    {

        return ValueTask.FromResult(context);        return ValueTask.FromResult(context);

    }    }

}}



public class AsyncDelayLink : ILinkpublic class AsyncDelayLink : ILink

{{

    public async ValueTask<Context> ProcessAsync(Context context)    public async ValueTask<Context> ProcessAsync(Context context)

    {    {

        var delay = (int?)context.Get("delay") ?? 100;        var delay = (int?)context.Get("delay") ?? 100;

        await Task.Delay(delay);        await Task.Delay(delay);

        return context.Insert("delayed", true);        return context.Insert("delayed", true);

    }    }

}}



// ===== TEST IMPLEMENTATION =====// ===== TEST IMPLEMENTATION =====



public class StandaloneTestRunnerpublic class StandaloneTestRunner

{{

    private static int _passedTests = 0;    private static int _passedTests = 0;

    private static int _failedTests = 0;    private static int _failedTests = 0;

    private static readonly List<string> _testResults = new();    private static readonly List<string> _testResults = new();



    public static async Task Main(string[] args)    public static async Task Main(string[] args)

    {    {

        Console.WriteLine("üß™ CodeUChain C# Standalone Comprehensive Test Suite");        Console.WriteLine("üß™ CodeUChain C# Standalone Comprehensive Test Suite");

        Console.WriteLine("==================================================\n");        Console.WriteLine("==================================================\n");



        var stopwatch = Stopwatch.StartNew();        var stopwatch = Stopwatch.StartNew();



        // Core Functionality Tests        // Core Functionality Tests

        await TestBasicContextOperations();        await TestBasicContextOperations();

        await TestTypedContextOperations();        await TestTypedContextOperations();

        await TestTypeEvolution();        await TestTypeEvolution();

        await TestGenericLinks();        await TestGenericLinks();

        await TestGenericChains();        await TestGenericChains();

        await TestMixedUsage();        await TestMixedUsage();

        await TestBackwardCompatibility();        await TestBackwardCompatibility();



        // Advanced Tests        // Advanced Tests

        await TestErrorHandling();        await TestErrorHandling();

        await TestEdgeCases();        await TestEdgeCases();

        await TestPerformance();        await TestPerformance();

        await TestChainComposition();        await TestChainComposition();



        // Middleware Tests        // Middleware Tests

        await TestMiddlewareFunctionality();        await TestMiddlewareFunctionality();

        await TestAsyncOperations();        await TestAsyncOperations();



        stopwatch.Stop();        stopwatch.Stop();



        // Summary        // Summary

        Console.WriteLine("\n" + "=".Repeat(50));        Console.WriteLine("\n" + "=".Repeat(50));

        Console.WriteLine("üìä STANDALONE COMPREHENSIVE TEST RESULTS");        Console.WriteLine("üìä STANDALONE COMPREHENSIVE TEST RESULTS");

        Console.WriteLine("=".Repeat(50));        Console.WriteLine("=".Repeat(50));

        Console.WriteLine($"Total Tests: {_passedTests + _failedTests}");        Console.WriteLine($"Total Tests: {_passedTests + _failedTests}");

        Console.WriteLine($"‚úÖ Passed: {_passedTests}");        Console.WriteLine($"‚úÖ Passed: {_passedTests}");

        Console.WriteLine($"‚ùå Failed: {_failedTests}");        Console.WriteLine($"‚ùå Failed: {_failedTests}");

        Console.WriteLine($"‚è±Ô∏è  Execution Time: {stopwatch.Elapsed.TotalSeconds:F2} seconds");        Console.WriteLine($"‚è±Ô∏è  Execution Time: {stopwatch.Elapsed.TotalSeconds:F2} seconds");

        Console.WriteLine($"üìà Success Rate: {(_passedTests * 100.0 / (_passedTests + _failedTests)):F1}%");        Console.WriteLine($"üìà Success Rate: {(_passedTests * 100.0 / (_passedTests + _failedTests)):F1}%");



        if (_failedTests > 0)        if (_failedTests > 0)

        {        {

            Console.WriteLine("\n‚ùå FAILED TESTS:");            Console.WriteLine("\n‚ùå FAILED TESTS:");

            foreach (var result in _testResults.Where(r => r.Contains("‚ùå")))            foreach (var result in _testResults.Where(r => r.Contains("‚ùå")))

            {            {

                Console.WriteLine($"  {result}");                Console.WriteLine($"  {result}");

            }            }

        }        }



        Console.WriteLine($"\nüéØ OVERALL STATUS: {(_failedTests == 0 ? "‚úÖ ALL TESTS PASSED" : "‚ùå SOME TESTS FAILED")}");        Console.WriteLine($"\nüéØ OVERALL STATUS: {(_failedTests == 0 ? "‚úÖ ALL TESTS PASSED" : "‚ùå SOME TESTS FAILED")}");

    }    }



    private static async Task TestBasicContextOperations()    private static async Task TestBasicContextOperations()

    {    {

        Console.WriteLine("üîç Testing Basic Context Operations...");        Console.WriteLine("üîç Testing Basic Context Operations...");



        // Test 1: Empty Context Creation        // Test 1: Empty Context Creation

        var emptyContext = Context.Create();        var emptyContext = Context.Create();

        Assert(emptyContext.Count == 0, "Empty context should have count 0");        Assert(emptyContext.Count == 0, "Empty context should have count 0");

        Assert(emptyContext.ToString() == "Context()", "Empty context string representation");        Assert(emptyContext.ToString() == "Context()", "Empty context string representation");



        // Test 2: Context with Initial Data        // Test 2: Context with Initial Data

        var initialData = new Dictionary<string, object>        var initialData = new Dictionary<string, object>

        {        {

            ["name"] = "Alice",            ["name"] = "Alice",

            ["age"] = 30,            ["age"] = 30,

            ["active"] = true            ["active"] = true

        };        };

        var context = Context.Create(initialData);        var context = Context.Create(initialData);

        Assert(context.Count == 3, "Context should have 3 items");        Assert(context.Count == 3, "Context should have 3 items");

        Assert(context.Get("name")?.ToString() == "Alice", "Should retrieve name correctly");        Assert(context.Get("name")?.ToString() == "Alice", "Should retrieve name correctly");

        Assert((int?)context.Get("age") == 30, "Should retrieve age correctly");        Assert((int?)context.Get("age") == 30, "Should retrieve age correctly");

        Assert((bool?)context.Get("active") == true, "Should retrieve active status correctly");        Assert((bool?)context.Get("active") == true, "Should retrieve active status correctly");



        // Test 3: Insert Operations        // Test 3: Insert Operations

        var updatedContext = context.Insert("city", "New York");        var updatedContext = context.Insert("city", "New York");

        Assert(updatedContext.Count == 4, "Updated context should have 4 items");        Assert(updatedContext.Count == 4, "Updated context should have 4 items");

        Assert(updatedContext.Get("city")?.ToString() == "New York", "Should retrieve inserted value");        Assert(updatedContext.Get("city")?.ToString() == "New York", "Should retrieve inserted value");



        // Test 4: Remove Operations        // Test 4: Remove Operations

        var removedContext = updatedContext.Remove("active");        var removedContext = updatedContext.Remove("active");

        Assert(removedContext.Count == 3, "Removed context should have 3 items");        Assert(removedContext.Count == 3, "Removed context should have 3 items");

        Assert(removedContext.Get("active") == null, "Removed key should return null");        Assert(removedContext.Get("active") == null, "Removed key should return null");



        // Test 5: Contains Key        // Test 5: Contains Key

        Assert(context.ContainsKey("name"), "Should contain existing key");        Assert(context.ContainsKey("name"), "Should contain existing key");

        Assert(!context.ContainsKey("nonexistent"), "Should not contain nonexistent key");        Assert(!context.ContainsKey("nonexistent"), "Should not contain nonexistent key");



        Console.WriteLine("‚úÖ Basic Context Operations: PASSED");        Console.WriteLine("‚úÖ Basic Context Operations: PASSED");

    }    }



    private static async Task TestTypedContextOperations()    private static async Task TestTypedContextOperations()

    {    {

        Console.WriteLine("üîç Testing Typed Context Operations...");        Console.WriteLine("üîç Testing Typed Context Operations...");



        // Test 1: Generic Context Creation        // Test 1: Generic Context Creation

        var typedContext = Context<string>.Create();        var typedContext = Context<string>.Create();

        Assert(typedContext.Count == 0, "Empty typed context should have count 0");        Assert(typedContext.Count == 0, "Empty typed context should have count 0");



        // Test 2: Typed Context with Initial Data        // Test 2: Typed Context with Initial Data

        var initialData = new Dictionary<string, object>        var initialData = new Dictionary<string, object>

        {        {

            ["message"] = "Hello World",            ["message"] = "Hello World",

            ["count"] = 42            ["count"] = 42

        };        };

        var context = Context<string>.Create(initialData);        var context = Context<string>.Create(initialData);

        Assert(context.Count == 2, "Typed context should have 2 items");        Assert(context.Count == 2, "Typed context should have 2 items");



        // Test 3: Typed Get Operations        // Test 3: Typed Get Operations

        var message = context.Get("message");        var message = context.Get("message");

        Assert(message == "Hello World", "Should retrieve typed string value");        Assert(message == "Hello World", "Should retrieve typed string value");



        var count = context.Get("count");        var count = context.Get("count");

        Assert(count == null, "Should return null for non-string type");        Assert(count == null, "Should return null for non-string type");



        // Test 4: GetAny Operations        // Test 4: GetAny Operations

        var anyMessage = context.GetAny("message");        var anyMessage = context.GetAny("message");

        Assert(anyMessage?.ToString() == "Hello World", "GetAny should retrieve any type");        Assert(anyMessage?.ToString() == "Hello World", "GetAny should retrieve any type");



        var anyCount = context.GetAny("count");        var anyCount = context.GetAny("count");

        Assert((int?)anyCount == 42, "GetAny should retrieve integer value");        Assert((int?)anyCount == 42, "GetAny should retrieve integer value");



        Console.WriteLine("‚úÖ Typed Context Operations: PASSED");        Console.WriteLine("‚úÖ Typed Context Operations: PASSED");

    }    }



    private static async Task TestTypeEvolution()    private static async Task TestTypeEvolution()

    {    {

        Console.WriteLine("üîç Testing Type Evolution...");        Console.WriteLine("üîç Testing Type Evolution...");



        // Test 1: Basic Type Evolution        // Test 1: Basic Type Evolution

        var stringContext = Context<string>.Create(new Dictionary<string, object>        var stringContext = Context<string>.Create(new Dictionary<string, object>

        {        {

            ["data"] = "initial"            ["data"] = "initial"

        });        });



        var objectContext = stringContext.InsertAs<object>("number", 100);        var objectContext = stringContext.InsertAs<object>("number", 100);

        Assert(objectContext.GetAny("number")?.ToString() == "100", "Should retrieve value from evolved context");        Assert(objectContext.GetAny("number")?.ToString() == "100", "Should retrieve value from evolved context");

        Assert(objectContext.Get("data") == null, "Should not retrieve string from object context");        Assert(objectContext.Get("data") == null, "Should not retrieve string from object context");



        // Test 2: Chain Type Evolution        // Test 2: Chain Type Evolution

        var context1 = Context<object>.Create(new Dictionary<string, object>        var context1 = Context<object>.Create(new Dictionary<string, object>

        {        {

            ["step"] = 1            ["step"] = 1

        });        });



        var context2 = context1.InsertAs<string>("message", "processing");        var context2 = context1.InsertAs<string>("message", "processing");

        var context3 = context2.InsertAs<object>("result", 42);        var context3 = context2.InsertAs<object>("result", 42);



        Assert(context3.GetAny("result")?.ToString() == "42", "Final context should have result");        Assert(context3.GetAny("result")?.ToString() == "42", "Final context should have result");

        Assert(context3.Get("message") == null, "Final context should not have string message");        Assert(context3.Get("message") == null, "Final context should not have string message");



        Console.WriteLine("‚úÖ Type Evolution: PASSED");        Console.WriteLine("‚úÖ Type Evolution: PASSED");

    }    }



    private static async Task TestGenericLinks()    private static async Task TestGenericLinks()

    {    {

        Console.WriteLine("üîç Testing Generic Links...");        Console.WriteLine("üîç Testing Generic Links...");



        // Test 1: Simple Generic Link        // Test 1: Simple Generic Link

        var stringToObjectLink = new StringToObjectLink();        var stringToObjectLink = new StringToObjectLink();

        var inputContext = Context<string>.Create(new Dictionary<string, object>        var inputContext = Context<string>.Create(new Dictionary<string, object>

        {        {

            ["value"] = "42"            ["value"] = "42"

        });        });



        var outputContext = await stringToObjectLink.CallAsync(inputContext);        var outputContext = await stringToObjectLink.CallAsync(inputContext);

        Assert(outputContext.GetAny("result")?.ToString() == "42", "Link should convert string to object");        Assert(outputContext.GetAny("result")?.ToString() == "42", "Link should convert string to object");



        // Test 2: Complex Generic Link        // Test 2: Complex Generic Link

        var processorLink = new DataProcessorLink();        var processorLink = new DataProcessorLink();

        var complexInput = Context<object>.Create(new Dictionary<string, object>        var complexInput = Context<object>.Create(new Dictionary<string, object>

        {        {

            ["data"] = "test",            ["data"] = "test",

            ["multiplier"] = 2            ["multiplier"] = 2

        });        });



        var complexOutput = await processorLink.CallAsync(complexInput);        var complexOutput = await processorLink.CallAsync(complexInput);

        Assert(complexOutput.GetAny("processed")?.ToString() == "TEST", "Should process string to uppercase");        Assert(complexOutput.GetAny("processed")?.ToString() == "TEST", "Should process string to uppercase");

        Assert(complexOutput.GetAny("calculated") == 4, "Should calculate doubled value");        Assert(complexOutput.GetAny("calculated") == 4, "Should calculate doubled value");



        Console.WriteLine("‚úÖ Generic Links: PASSED");        Console.WriteLine("‚úÖ Generic Links: PASSED");

    }    }



    private static async Task TestGenericChains()    private static async Task TestGenericChains()

    {    {

        Console.WriteLine("üîç Testing Generic Chains...");        Console.WriteLine("üîç Testing Generic Chains...");



        // Test 1: Simple Generic Chain        // Test 1: Simple Generic Chain

        var chain = new Chain<string, object>()        var chain = new Chain<string, object>()

            .AddLink("parse", new StringToObjectLink())            .AddLink("parse", new StringToObjectLink())

            .AddLink("double", new DoubleValueLink());            .AddLink("double", new DoubleValueLink());



        var input = Context<string>.Create(new Dictionary<string, object>        var input = Context<string>.Create(new Dictionary<string, object>

        {        {

            ["value"] = "21"            ["value"] = "21"

        });        });



        var result = await chain.RunAsync(input);        var result = await chain.RunAsync(input);

        Assert(result.GetAny("final")?.ToString() == "42", "Chain should process string to doubled value");        Assert(result.GetAny("final")?.ToString() == "42", "Chain should process string to doubled value");



        Console.WriteLine("‚úÖ Generic Chains: PASSED");        Console.WriteLine("‚úÖ Generic Chains: PASSED");

    }    }



    private static async Task TestMixedUsage()    private static async Task TestMixedUsage()

    {    {

        Console.WriteLine("üîç Testing Mixed Usage...");        Console.WriteLine("üîç Testing Mixed Usage...");



        // Test 1: Mixed Typed and Untyped Contexts        // Test 1: Mixed Typed and Untyped Contexts

        var untypedContext = Context.Create(new Dictionary<string, object>        var untypedContext = Context.Create(new Dictionary<string, object>

        {        {

            ["data"] = "mixed"            ["data"] = "mixed"

        });        });



        var typedContext = Context<string>.Create(new Dictionary<string, object>        var typedContext = Context<string>.Create(new Dictionary<string, object>

        {        {

            ["typed"] = "data"            ["typed"] = "data"

        });        });



        // Test 2: Mixed Links        // Test 2: Mixed Links

        var mixedChain = new Chain<object, object>()        var mixedChain = new Chain<object, object>()

            .AddLink("untyped", new UntypedProcessorLink())            .AddLink("untyped", new UntypedProcessorLink())

            .AddLink("typed", new TypedProcessorLink());            .AddLink("typed", new TypedProcessorLink());



        var mixedResult = await mixedChain.RunAsync(untypedContext);        var mixedResult = await mixedChain.RunAsync(untypedContext);

        Assert(mixedResult.GetAny("processed") != null, "Mixed chain should process successfully");        Assert(mixedResult.GetAny("processed") != null, "Mixed chain should process successfully");



        Console.WriteLine("‚úÖ Mixed Usage: PASSED");        Console.WriteLine("‚úÖ Mixed Usage: PASSED");

    }    }



    private static async Task TestBackwardCompatibility()    private static async Task TestBackwardCompatibility()

    {    {

        Console.WriteLine("üîç Testing Backward Compatibility...");        Console.WriteLine("üîç Testing Backward Compatibility...");



        // Test 1: Original Untyped Chain        // Test 1: Original Untyped Chain

        var untypedChain = new Chain()        var untypedChain = new Chain()

            .AddLink("process", new LegacyProcessor())            .AddLink("process", new LegacyProcessor())

            .UseMiddleware(new LoggingMiddleware());            .UseMiddleware(new LoggingMiddleware());



        var untypedInput = Context.Create(new Dictionary<string, object>        var untypedInput = Context.Create(new Dictionary<string, object>

        {        {

            ["input"] = "legacy"            ["input"] = "legacy"

        });        });



        var untypedResult = await untypedChain.RunAsync(untypedInput);        var untypedResult = await untypedChain.RunAsync(untypedInput);

        Assert(untypedResult.Get("output")?.ToString() == "LEGACY", "Untyped chain should work");        Assert(untypedResult.Get("output")?.ToString() == "LEGACY", "Untyped chain should work");



        Console.WriteLine("‚úÖ Backward Compatibility: PASSED");        Console.WriteLine("‚úÖ Backward Compatibility: PASSED");

    }    }



    private static async Task TestErrorHandling()    private static async Task TestErrorHandling()

    {    {

        Console.WriteLine("üîç Testing Error Handling...");        Console.WriteLine("üîç Testing Error Handling...");



        // Test 1: Link Error Handling        // Test 1: Link Error Handling

        var errorChain = new Chain<object, object>()        var errorChain = new Chain<object, object>()

            .AddLink("error", new ErrorLink());            .AddLink("error", new ErrorLink());



        var errorInput = Context<object>.Create(new Dictionary<string, object>        var errorInput = Context<object>.Create(new Dictionary<string, object>

        {        {

            ["trigger"] = "error"            ["trigger"] = "error"

        });        });



        try        try

        {        {

            await errorChain.RunAsync(errorInput);            await errorChain.RunAsync(errorInput);

            Assert(false, "Should have thrown exception");            Assert(false, "Should have thrown exception");

        }        }

        catch (InvalidOperationException ex)        catch (InvalidOperationException ex)

        {        {

            Assert(ex.Message == "Test error", "Should catch correct exception");            Assert(ex.Message == "Test error", "Should catch correct exception");

        }        }



        Console.WriteLine("‚úÖ Error Handling: PASSED");        Console.WriteLine("‚úÖ Error Handling: PASSED");

    }    }



    private static async Task TestEdgeCases()    private static async Task TestEdgeCases()

    {    {

        Console.WriteLine("üîç Testing Edge Cases...");        Console.WriteLine("üîç Testing Edge Cases...");



        // Test 1: Empty Chains        // Test 1: Empty Chains

        var emptyChain = new Chain<object, object>();        var emptyChain = new Chain<object, object>();

        var emptyResult = await emptyChain.RunAsync(Context<object>.Create());        var emptyResult = await emptyChain.RunAsync(Context<object>.Create());

        Assert(emptyResult.Count == 0, "Empty chain should return empty context");        Assert(emptyResult.Count == 0, "Empty chain should return empty context");



        // Test 2: Null Values        // Test 2: Null Values

        var nullContext = Context.Create();        var nullContext = Context.Create();

        nullContext = nullContext.Insert("nullValue", null);        nullContext = nullContext.Insert("nullValue", null);

        Assert(nullContext.Get("nullValue") == null, "Should handle null values");        Assert(nullContext.Get("nullValue") == null, "Should handle null values");



        Console.WriteLine("‚úÖ Edge Cases: PASSED");        Console.WriteLine("‚úÖ Edge Cases: PASSED");

    }    }



    private static async Task TestPerformance()    private static async Task TestPerformance()

    {    {

        Console.WriteLine("üîç Testing Performance...");        Console.WriteLine("üîç Testing Performance...");



        var stopwatch = Stopwatch.StartNew();        var stopwatch = Stopwatch.StartNew();



        // Test 1: Chain Performance        // Test 1: Chain Performance

        var perfChain = new Chain<object, object>()        var perfChain = new Chain<object, object>()

            .AddLink("step1", new PerformanceLink())            .AddLink("step1", new PerformanceLink())

            .AddLink("step2", new PerformanceLink())            .AddLink("step2", new PerformanceLink())

            .AddLink("step3", new PerformanceLink());            .AddLink("step3", new PerformanceLink());



        var perfInput = Context<object>.Create(new Dictionary<string, object>        var perfInput = Context<object>.Create(new Dictionary<string, object>

        {        {

            ["iterations"] = 10            ["iterations"] = 10

        });        });



        stopwatch.Start();        stopwatch.Start();

        var perfResult = await perfChain.RunAsync(perfInput);        var perfResult = await perfChain.RunAsync(perfInput);

        stopwatch.Stop();        stopwatch.Stop();



        var executionTime = stopwatch.Elapsed.TotalMilliseconds;        var executionTime = stopwatch.Elapsed.TotalMilliseconds;

        Assert(executionTime < 1000, $"Chain should execute quickly, took {executionTime}ms");        Assert(executionTime < 1000, $"Chain should execute quickly, took {executionTime}ms");

        Assert(perfResult.GetAny("total")?.ToString() == "30", "Should accumulate results correctly");        Assert(perfResult.GetAny("total")?.ToString() == "30", "Should accumulate results correctly");



        Console.WriteLine($"‚úÖ Performance: PASSED ({executionTime:F2}ms)");        Console.WriteLine($"‚úÖ Performance: PASSED ({executionTime:F2}ms)");

    }    }



    private static async Task TestChainComposition()    private static async Task TestChainComposition()

    {    {

        Console.WriteLine("üîç Testing Chain Composition...");        Console.WriteLine("üîç Testing Chain Composition...");



        // Test 1: Nested Chains        // Test 1: Nested Chains

        var innerChain = new Chain<object, object>()        var innerChain = new Chain<object, object>()

            .AddLink("double", new DoubleValueLink());            .AddLink("double", new DoubleValueLink());



        var outerChain = new Chain<object, object>()        var outerChain = new Chain<object, object>()

            .AddLink("convert", new ObjectToStringLink())            .AddLink("convert", new ObjectToStringLink())

            .AddLink("process", new NestedChainLink(innerChain))            .AddLink("process", new NestedChainLink(innerChain))

            .AddLink("format", new StringToObjectLink());            .AddLink("format", new StringToObjectLink());



        var nestedInput = Context<object>.Create(new Dictionary<string, object>        var nestedInput = Context<object>.Create(new Dictionary<string, object>

        {        {

            ["value"] = "10"            ["value"] = "10"

        });        });



        var nestedResult = await outerChain.RunAsync(nestedInput);        var nestedResult = await outerChain.RunAsync(nestedInput);

        Assert(nestedResult.GetAny("final")?.ToString() == "40", "Nested chain should work correctly");        Assert(nestedResult.GetAny("final")?.ToString() == "40", "Nested chain should work correctly");



        Console.WriteLine("‚úÖ Chain Composition: PASSED");        Console.WriteLine("‚úÖ Chain Composition: PASSED");

    }    }



    private static async Task TestMiddlewareFunctionality()    private static async Task TestMiddlewareFunctionality()

    {    {

        Console.WriteLine("üîç Testing Middleware Functionality...");        Console.WriteLine("üîç Testing Middleware Functionality...");



        // Test 1: Basic Middleware        // Test 1: Basic Middleware

        var middlewareChain = new Chain()        var middlewareChain = new Chain()

            .AddLink("process", new SimpleLink())            .AddLink("process", new SimpleLink())

            .UseMiddleware(new TimingMiddleware())            .UseMiddleware(new TimingMiddleware())

            .UseMiddleware(new LoggingMiddleware());            .UseMiddleware(new LoggingMiddleware());



        var middlewareInput = Context.Create(new Dictionary<string, object>        var middlewareInput = Context.Create(new Dictionary<string, object>

        {        {

            ["input"] = "test"            ["input"] = "test"

        });        });



        var middlewareResult = await middlewareChain.RunAsync(middlewareInput);        var middlewareResult = await middlewareChain.RunAsync(middlewareInput);

        Assert(middlewareResult.Get("processed")?.ToString() == "TEST", "Middleware chain should work");        Assert(middlewareResult.Get("processed")?.ToString() == "TEST", "Middleware chain should work");



        Console.WriteLine("‚úÖ Middleware Functionality: PASSED");        Console.WriteLine("‚úÖ Middleware Functionality: PASSED");

    }    }



    private static async Task TestAsyncOperations()    private static async Task TestAsyncOperations()

    {    {

        Console.WriteLine("üîç Testing Async Operations...");        Console.WriteLine("üîç Testing Async Operations...");



        // Test 1: Async Links        // Test 1: Async Links

        var asyncChain = new Chain()        var asyncChain = new Chain()

            .AddLink("async1", new AsyncDelayLink())            .AddLink("async1", new AsyncDelayLink())

            .AddLink("async2", new AsyncDelayLink());            .AddLink("async2", new AsyncDelayLink());



        var asyncInput = Context.Create(new Dictionary<string, object>        var asyncInput = Context.Create(new Dictionary<string, object>

        {        {

            ["delay"] = 10            ["delay"] = 10

        });        });



        var stopwatch = Stopwatch.StartNew();        var stopwatch = Stopwatch.StartNew();

        var asyncResult = await asyncChain.RunAsync(asyncInput);        var asyncResult = await asyncChain.RunAsync(asyncInput);

        stopwatch.Stop();        stopwatch.Stop();



        // Should complete in ~20ms (2 delays of 10ms each)        // Should complete in ~20ms (2 delays of 10ms each)

        Assert(stopwatch.Elapsed.TotalMilliseconds < 100, "Async operations should be efficient");        Assert(stopwatch.Elapsed.TotalMilliseconds < 100, "Async operations should be efficient");

        Assert(asyncResult.Get("delayed") != null, "Async chain should complete successfully");        Assert(asyncResult.Get("delayed") != null, "Async chain should complete successfully");



        Console.WriteLine($"‚úÖ Async Operations: PASSED ({stopwatch.Elapsed.TotalMilliseconds:F2}ms)");        Console.WriteLine($"‚úÖ Async Operations: PASSED ({stopwatch.Elapsed.TotalMilliseconds:F2}ms)");

    }    }



    private static void Assert(bool condition, string message)    private static void Assert(bool condition, string message)

    {    {

        if (condition)        if (condition)

        {        {

            _passedTests++;            _passedTests++;

            _testResults.Add($"‚úÖ {message}");            _testResults.Add($"‚úÖ {message}");

        }        }

        else        else

        {        {

            _failedTests++;            _failedTests++;

            _testResults.Add($"‚ùå {message}");            _testResults.Add($"‚ùå {message}");

            Console.WriteLine($"‚ùå ASSERTION FAILED: {message}");            Console.WriteLine($"‚ùå ASSERTION FAILED: {message}");

        }        }

    }    }

}}



    /// <summary>    /// <summary>

    /// Retrieves a typed value from the context.    /// Retrieves a typed value from the context.

    /// </summary>    /// </summary>

    public T? Get<T>(string key)    public T? Get<T>(string key)

    {    {

        return _data.TryGetValue(key, out var value) && value is T typedValue ? typedValue : default;        return _data.TryGetValue(key, out var value) && value is T typedValue ? typedValue : default;

    }    }



    /// <summary>    /// <summary>

    /// Checks if the context contains a key.    /// Checks if the context contains a key.

    /// </summary>    /// </summary>

    public bool ContainsKey(string key)    public bool ContainsKey(string key)

    {    {

        return _data.ContainsKey(key);        return _data.ContainsKey(key);

    }    }



    /// <summary>    /// <summary>

    /// Returns a new context with the specified key-value pair inserted.    /// Returns a new context with the specified key-value pair inserted.

    /// </summary>    /// </summary>

    public Context Insert(string key, object value)    public Context Insert(string key, object value)

    {    {

        return new Context(_data.SetItem(key, value));        return new Context(_data.SetItem(key, value));

    }    }



    /// <summary>    /// <summary>

    /// Type Evolution: Insert with type transformation    /// Type Evolution: Insert with type transformation

    /// Returns a new context with the specified key-value pair inserted, enabling clean type evolution.    /// Returns a new context with the specified key-value pair inserted, enabling clean type evolution.

    /// This method allows transforming the context's type without explicit casting.    /// This method allows transforming the context's type without explicit casting.

    /// </summary>    /// </summary>

    public Context InsertAs(string key, object value)    public Context InsertAs(string key, object value)

    {    {

        return new Context(_data.SetItem(key, value));        return new Context(_data.SetItem(key, value));

    }    }



    /// <summary>    /// <summary>

    /// Returns a new context with the specified key removed.    /// Returns a new context with the specified key removed.

    /// </summary>    /// </summary>

    public Context Remove(string key)    public Context Remove(string key)

    {    {

        return new Context(_data.Remove(key));        return new Context(_data.Remove(key));

    }    }



    /// <summary>    /// <summary>

    /// Returns all keys in the context.    /// Returns all keys in the context.

    /// </summary>    /// </summary>

    public IEnumerable<string> Keys => _data.Keys;    public IEnumerable<string> Keys => _data.Keys;



    /// <summary>    /// <summary>

    /// Returns all values in the context.    /// Returns all values in the context.

    /// </summary>    /// </summary>

    public IEnumerable<object> Values => _data.Values;    public IEnumerable<object> Values => _data.Values;



    /// <summary>    /// <summary>

    /// Returns the number of items in the context.    /// Returns the number of items in the context.

    /// </summary>    /// </summary>

    public int Count => _data.Count;    public int Count => _data.Count;



    /// <summary>    /// <summary>

    /// Returns a string representation of the context.    /// Returns a string representation of the context.

    /// </summary>    /// </summary>

    public override string ToString()    public override string ToString()

    {    {

        return $"Context({string.Join(", ", _data.Select(kv => $"{kv.Key}: {kv.Value}"))})";        return $"Context({string.Join(", ", _data.Select(kv => $"{kv.Key}: {kv.Value}"))})";

    }    }

}}



/// <summary>/// <summary>

/// Generic Context: Opt-in Type Safety/// Generic Context: Opt-in Type Safety

/// Strongly-typed version of Context for static type checking while maintaining runtime flexibility./// Strongly-typed version of Context for static type checking while maintaining runtime flexibility.

/// Supports clean type evolution through InsertAs<U>() method./// Supports clean type evolution through InsertAs<U>() method.

/// Follows the universal pattern across all CodeUChain languages./// Follows the universal pattern across all CodeUChain languages.

/// </summary>/// </summary>

public class Context<T> where T : classpublic class Context<T> where T : class

{{

    private readonly ImmutableDictionary<string, object> _data;    private readonly ImmutableDictionary<string, object> _data;



    private Context(ImmutableDictionary<string, object> data)    private Context(ImmutableDictionary<string, object> data)

    {    {

        _data = data;        _data = data;

    }    }



    /// <summary>    /// <summary>

    /// Creates a new empty generic context.    /// Creates a new empty generic context.

    /// </summary>    /// </summary>

    public static Context<T> Create()    public static Context<T> Create()

    {    {

        return new Context<T>(ImmutableDictionary<string, object>.Empty);        return new Context<T>(ImmutableDictionary<string, object>.Empty);

    }    }



    /// <summary>    /// <summary>

    /// Creates a new generic context with initial data.    /// Creates a new generic context with initial data.

    /// </summary>    /// </summary>

    public static Context<T> Create(IDictionary<string, object> data)    public static Context<T> Create(IDictionary<string, object> data)

    {    {

        return new Context<T>(data.ToImmutableDictionary());        return new Context<T>(data.ToImmutableDictionary());

    }    }



    /// <summary>    /// <summary>

    /// Retrieves a typed value from the context.    /// Retrieves a typed value from the context.

    /// </summary>    /// </summary>

    public T? Get(string key)    public T? Get(string key)

    {    {

        return _data.TryGetValue(key, out var value) && value is T typedValue ? typedValue : default;        return _data.TryGetValue(key, out var value) && value is T typedValue ? typedValue : default;

    }    }



    /// <summary>    /// <summary>

    /// Retrieves a value of any type from the context.    /// Retrieves a value of any type from the context.

    /// </summary>    /// </summary>

    public object? GetAny(string key)    public object? GetAny(string key)

    {    {

        return _data.TryGetValue(key, out var value) ? value : null;        return _data.TryGetValue(key, out var value) ? value : null;

    }    }



    /// <summary>    /// <summary>

    /// Checks if the context contains a key.    /// Checks if the context contains a key.

    /// </summary>    /// </summary>

    public bool ContainsKey(string key)    public bool ContainsKey(string key)

    {    {

        return _data.ContainsKey(key);        return _data.ContainsKey(key);

    }    }



    /// <summary>    /// <summary>

    /// Type Preservation: Insert that maintains current type T    /// Type Preservation: Insert that maintains current type T

    /// Returns a new context with the specified key-value pair inserted.    /// Returns a new context with the specified key-value pair inserted.

    /// </summary>    /// </summary>

    public Context<T> Insert(string key, object value)    public Context<T> Insert(string key, object value)

    {    {

        return new Context<T>(_data.SetItem(key, value));        return new Context<T>(_data.SetItem(key, value));

    }    }



    /// <summary>    /// <summary>

    /// Type Evolution: Insert with type transformation    /// Type Evolution: Insert with type transformation

    /// Returns a new context with the specified key-value pair inserted, enabling clean type evolution.    /// Returns a new context with the specified key-value pair inserted, enabling clean type evolution.

    /// This method allows transforming the context's type to U without explicit casting.    /// This method allows transforming the context's type to U without explicit casting.

    /// </summary>    /// </summary>

    public Context<U> InsertAs<U>(string key, object value) where U : class    public Context<U> InsertAs<U>(string key, object value) where U : class

    {    {

        return new Context<U>(_data.SetItem(key, value));        return new Context<U>(_data.SetItem(key, value));

    }    }



    /// <summary>    /// <summary>

    /// Returns a new context with the specified key removed.    /// Returns a new context with the specified key removed.

    /// </summary>    /// </summary>

    public Context<T> Remove(string key)    public Context<T> Remove(string key)

    {    {

        return new Context<T>(_data.Remove(key));        return new Context<T>(_data.Remove(key));

    }    }



    /// <summary>    /// <summary>

    /// Returns all keys in the context.    /// Returns all keys in the context.

    /// </summary>    /// </summary>

    public IEnumerable<string> Keys => _data.Keys;    public IEnumerable<string> Keys => _data.Keys;



    /// <summary>    /// <summary>

    /// Returns all values in the context.    /// Returns all values in the context.

    /// </summary>    /// </summary>

    public IEnumerable<object> Values => _data.Values;    public IEnumerable<object> Values => _data.Values;



    /// <summary>    /// <summary>

    /// Returns the number of items in the context.    /// Returns the number of items in the context.

    /// </summary>    /// </summary>

    public int Count => _data.Count;    public int Count => _data.Count;



    /// <summary>    /// <summary>

    /// Returns a string representation of the generic context.    /// Returns a string representation of the generic context.

    /// </summary>    /// </summary>

    public override string ToString()    public override string ToString()

    {    {

        return $"Context<{typeof(T).Name}>({string.Join(", ", _data.Select(kv => $"{kv.Key}: {kv.Value}"))})";        return $"Context<{typeof(T).Name}>({string.Join(", ", _data.Select(kv => $"{kv.Key}: {kv.Value}"))})";

    }    }

}}



/// <summary>/// <summary>

/// Link: The Processing Unit Interface/// Link: The Processing Unit Interface

/// Unified interface that handles both sync and async operations automatically./// Unified interface that handles both sync and async operations automatically.

/// </summary>/// </summary>

public interface ILinkpublic interface ILink

{{

    /// <summary>    /// <summary>

    /// Processes the context and returns a new context.    /// Processes the context and returns a new context.

    /// Can be implemented as sync or async - the chain handles both automatically.    /// Can be implemented as sync or async - the chain handles both automatically.

    /// </summary>    /// </summary>

    /// <param name="context">The input context</param>    /// <param name="context">The input context</param>

    /// <returns>The processed context</returns>    /// <returns>The processed context</returns>

    ValueTask<Context> ProcessAsync(Context context);    ValueTask<Context> ProcessAsync(Context context);

}}



/// <summary>/// <summary>

/// Generic Link interface for context-based processing./// Generic Link interface for context-based processing.

/// Follows the universal Link[Input, Output] pattern across all CodeUChain languages./// Follows the universal Link[Input, Output] pattern across all CodeUChain languages.

/// </summary>/// </summary>

public interface IContextLink<TInput, TOutput>public interface IContextLink<TInput, TOutput>

    where TInput : class    where TInput : class

    where TOutput : class    where TOutput : class

{{

    Task<Context<TOutput>> CallAsync(Context<TInput> context);    Task<Context<TOutput>> CallAsync(Context<TInput> context);

}}



/// <summary>/// <summary>

/// Middleware: The Chain Enhancement Interface/// Middleware: The Chain Enhancement Interface

/// Provides hooks for intercepting and modifying chain execution./// Provides hooks for intercepting and modifying chain execution.

/// Unified middleware that handles both sync and async operations./// Unified middleware that handles both sync and async operations.

/// </summary>/// </summary>

public interface IMiddlewarepublic interface IMiddleware

{{

    /// <summary>    /// <summary>

    /// Called before a link is executed.    /// Called before a link is executed.

    /// </summary>    /// </summary>

    ValueTask<Context> BeforeAsync(ILink? link, Context context);    ValueTask<Context> BeforeAsync(ILink? link, Context context);



    /// <summary>    /// <summary>

    /// Called after a link is executed successfully.    /// Called after a link is executed successfully.

    /// </summary>    /// </summary>

    ValueTask<Context> AfterAsync(ILink? link, Context context);    ValueTask<Context> AfterAsync(ILink? link, Context context);



    /// <summary>    /// <summary>

    /// Called when a link throws an exception.    /// Called when a link throws an exception.

    /// </summary>    /// </summary>

    ValueTask<Context> OnErrorAsync(ILink? link, Exception exception, Context context);    ValueTask<Context> OnErrorAsync(ILink? link, Exception exception, Context context);

}}



/// <summary>/// <summary>

/// Generic Middleware interface./// Generic Middleware interface.

/// Simplified for type-evolving chains - middleware operates on the current context type./// Simplified for type-evolving chains - middleware operates on the current context type.

/// </summary>/// </summary>

public interface IMiddleware<T>public interface IMiddleware<T>

    where T : class    where T : class

{{

    Task<Context<T>> BeforeAsync(IContextLink<T, T>? link, Context<T> context);    Task<Context<T>> BeforeAsync(IContextLink<T, T>? link, Context<T> context);

    Task<Context<T>> AfterAsync(IContextLink<T, T>? link, Context<T> context);    Task<Context<T>> AfterAsync(IContextLink<T, T>? link, Context<T> context);

    Task<Context<T>> OnErrorAsync(IContextLink<T, T>? link, Exception exception, Context<T> context);    Task<Context<T>> OnErrorAsync(IContextLink<T, T>? link, Exception exception, Context<T> context);

}}



/// <summary>/// <summary>

/// Chain: The Harmonious Connector/// Chain: The Harmonious Connector

/// Unified implementation that handles both sync and async operations seamlessly./// Unified implementation that handles both sync and async operations seamlessly.

/// </summary>/// </summary>

public class Chainpublic class Chain

{{

    private readonly ImmutableList<KeyValuePair<string, ILink>> _links;    private readonly ImmutableList<KeyValuePair<string, ILink>> _links;

    private readonly ImmutableList<IMiddleware> _middlewares;    private readonly ImmutableList<IMiddleware> _middlewares;



    private Chain(ImmutableList<KeyValuePair<string, ILink>> links, ImmutableList<IMiddleware> middlewares)    private Chain(ImmutableList<KeyValuePair<string, ILink>> links, ImmutableList<IMiddleware> middlewares)

    {    {

        _links = links;        _links = links;

        _middlewares = middlewares;        _middlewares = middlewares;

    }    }



    public Chain()    public Chain()

    {    {

        _links = ImmutableList<KeyValuePair<string, ILink>>.Empty;        _links = ImmutableList<KeyValuePair<string, ILink>>.Empty;

        _middlewares = ImmutableList<IMiddleware>.Empty;        _middlewares = ImmutableList<IMiddleware>.Empty;

    }    }



    /// <summary>    /// <summary>

    /// Adds a link to the chain.    /// Adds a link to the chain.

    /// </summary>    /// </summary>

    public Chain AddLink(string name, ILink link)    public Chain AddLink(string name, ILink link)

    {    {

        return new Chain(_links.Add(new KeyValuePair<string, ILink>(name, link)), _middlewares);        return new Chain(_links.Add(new KeyValuePair<string, ILink>(name, link)), _middlewares);

    }    }



    /// <summary>    /// <summary>

    /// Adds middleware to the chain.    /// Adds middleware to the chain.

    /// </summary>    /// </summary>

    public Chain UseMiddleware(IMiddleware middleware)    public Chain UseMiddleware(IMiddleware middleware)

    {    {

        return new Chain(_links, _middlewares.Add(middleware));        return new Chain(_links, _middlewares.Add(middleware));

    }    }



    /// <summary>    /// <summary>

    /// Executes the chain. Automatically handles sync/async based on the links.    /// Executes the chain. Automatically handles sync/async based on the links.

    /// </summary>    /// </summary>

    public async ValueTask<Context> RunAsync(Context initialContext)    public async ValueTask<Context> RunAsync(Context initialContext)

    {    {

        var currentContext = initialContext;        var currentContext = initialContext;



        // Execute before hooks        // Execute before hooks

        foreach (var middleware in _middlewares)        foreach (var middleware in _middlewares)

        {        {

            try            try

            {            {

                currentContext = await middleware.BeforeAsync(null, currentContext);                currentContext = await middleware.BeforeAsync(null, currentContext);

            }            }

            catch (Exception ex)            catch (Exception ex)

            {            {

                // Handle middleware errors                // Handle middleware errors

                foreach (var errorMiddleware in _middlewares)                foreach (var errorMiddleware in _middlewares)

                {                {

                    try                    try

                    {                    {

                        currentContext = await errorMiddleware.OnErrorAsync(null, ex, currentContext);                        currentContext = await errorMiddleware.OnErrorAsync(null, ex, currentContext);

                    }                    }

                    catch                    catch

                    {                    {

                        // Continue with other error handlers                        // Continue with other error handlers

                    }                    }

                }                }

                throw;                throw;

            }            }

        }        }



        // Execute links        // Execute links

        foreach (var (name, link) in _links)        foreach (var (name, link) in _links)

        {        {

            // Before each link            // Before each link

            foreach (var middleware in _middlewares)            foreach (var middleware in _middlewares)

            {            {

                try                try

                {                {

                    currentContext = await middleware.BeforeAsync(link, currentContext);                    currentContext = await middleware.BeforeAsync(link, currentContext);

                }                }

                catch (Exception ex)                catch (Exception ex)

                {                {

                    // Handle middleware errors                    // Handle middleware errors

                    foreach (var errorMiddleware in _middlewares)                    foreach (var errorMiddleware in _middlewares)

                    {                    {

                        try                        try

                        {                        {

                            currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);                            currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);

                        }                        }

                        catch                        catch

                        {                        {

                            // Continue with other error handlers                            // Continue with other error handlers

                        }                        }

                    }                    }

                    throw;                    throw;

                }                }

            }            }



            // Execute link            // Execute link

            try            try

            {            {

                currentContext = await link.ProcessAsync(currentContext);                currentContext = await link.ProcessAsync(currentContext);

            }            }

            catch (Exception ex)            catch (Exception ex)

            {            {

                // Handle link errors                // Handle link errors

                foreach (var middleware in _middlewares)                foreach (var middleware in _middlewares)

                {                {

                    try                    try

                    {                    {

                        currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);                        currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);

                    }                    }

                    catch                    catch

                    {                    {

                        // Continue with other error handlers                        // Continue with other error handlers

                    }                    }

                }                }

                throw;                throw;

            }            }



            // After each link            // After each link

            foreach (var middleware in _middlewares)            foreach (var middleware in _middlewares)

            {            {

                try                try

                {                {

                    currentContext = await middleware.AfterAsync(link, currentContext);                    currentContext = await middleware.AfterAsync(link, currentContext);

                }                }

                catch (Exception ex)                catch (Exception ex)

                {                {

                    // Handle middleware errors                    // Handle middleware errors

                    foreach (var errorMiddleware in _middlewares)                    foreach (var errorMiddleware in _middlewares)

                    {                    {

                        try                        try

                        {                        {

                            currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);                            currentContext = await errorMiddleware.OnErrorAsync(link, ex, currentContext);

                        }                        }

                        catch                        catch

                        {                        {

                            // Continue with other error handlers                            // Continue with other error handlers

                        }                        }

                    }                    }

                    throw;                    throw;

                }                }

            }            }

        }        }



        // Final after hooks        // Final after hooks

        foreach (var middleware in _middlewares)        foreach (var middleware in _middlewares)

        {        {

            try            try

            {            {

                currentContext = await middleware.AfterAsync(null, currentContext);                currentContext = await middleware.AfterAsync(null, currentContext);

            }            }

            catch (Exception ex)            catch (Exception ex)

            {            {

                // Handle middleware errors                // Handle middleware errors

                foreach (var errorMiddleware in _middlewares)                foreach (var errorMiddleware in _middlewares)

                {                {

                    try                    try

                    {                    {

                        currentContext = await errorMiddleware.OnErrorAsync(null, ex, currentContext);                        currentContext = await errorMiddleware.OnErrorAsync(null, ex, currentContext);

                    }                    }

                    catch                    catch

                    {                    {

                        // Continue with other error handlers                        // Continue with other error handlers

                    }                    }

                }                }

                throw;                throw;

            }            }

        }        }



        return currentContext;        return currentContext;

    }    }



    /// <summary>    /// <summary>

    /// Synchronous execution - blocks if any async operations are present.    /// Synchronous execution - blocks if any async operations are present.

    /// </summary>    /// </summary>

    public Context RunSync(Context initialContext)    public Context RunSync(Context initialContext)

    {    {

        return RunAsync(initialContext).GetAwaiter().GetResult();        return RunAsync(initialContext).GetAwaiter().GetResult();

    }    }

}}



/// <summary>/// <summary>

/// Generic Chain with type safety./// Generic Chain with type safety.

/// Supports the universal Link[Input, Output] pattern for clean type evolution./// Supports the universal Link[Input, Output] pattern for clean type evolution.

/// Note: Middleware is simplified to work with single types for now./// Note: Middleware is simplified to work with single types for now.

/// </summary>/// </summary>

public class Chain<TInput, TOutput>public class Chain<TInput, TOutput>

    where TInput : class    where TInput : class

    where TOutput : class    where TOutput : class

{{

    private readonly ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>> _links;    private readonly ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>> _links;



    private Chain(ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>> links)    private Chain(ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>> links)

    {    {

        _links = links;        _links = links;

    }    }



    public Chain()    public Chain()

    {    {

        _links = ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>>.Empty;        _links = ImmutableList<KeyValuePair<string, IContextLink<TInput, TOutput>>>.Empty;

    }    }



    /// <summary>    /// <summary>

    /// Adds a link to the chain.    /// Adds a link to the chain.

    /// </summary>    /// </summary>

    public Chain<TInput, TOutput> AddLink(string name, IContextLink<TInput, TOutput> link)    public Chain<TInput, TOutput> AddLink(string name, IContextLink<TInput, TOutput> link)

    {    {

        return new Chain<TInput, TOutput>(_links.Add(new KeyValuePair<string, IContextLink<TInput, TOutput>>(name, link)));        return new Chain<TInput, TOutput>(_links.Add(new KeyValuePair<string, IContextLink<TInput, TOutput>>(name, link)));

    }    }



    /// <summary>    /// <summary>

    /// Executes the chain with the given context.    /// Executes the chain with the given context.

    /// </summary>    /// </summary>

    public async Task<Context<TOutput>> RunAsync(Context<TInput> initialContext)    public async Task<Context<TOutput>> RunAsync(Context<TInput> initialContext)

    {    {

        // For a chain with type evolution, we need to handle the type transformation properly        // For a chain with type evolution, we need to handle the type transformation properly

        // This is a simplified implementation - in practice, you'd want a more sophisticated approach        // This is a simplified implementation - in practice, you'd want a more sophisticated approach



        Context<TInput> currentInputContext = initialContext;        Context<TInput> currentInputContext = initialContext;

        Context<TOutput> currentOutputContext = default!;        Context<TOutput> currentOutputContext = default!;



        // Execute links with type evolution        // Execute links with type evolution

        foreach (var (name, link) in _links)        foreach (var (name, link) in _links)

        {        {

            try            try

            {            {

                currentOutputContext = await link.CallAsync(currentInputContext);                currentOutputContext = await link.CallAsync(currentInputContext);

                // For subsequent links, we need to adapt the context type                // For subsequent links, we need to adapt the context type

                // This is a limitation of the current simplified implementation                // This is a limitation of the current simplified implementation

                currentInputContext = currentOutputContext.InsertAs<TInput>("__temp", new object()).Remove("__temp");                currentInputContext = currentOutputContext.InsertAs<TInput>("__temp", new object()).Remove("__temp");

            }            }

            catch (Exception)            catch (Exception)

            {            {

                // For now, rethrow exceptions - middleware can be added later                // For now, rethrow exceptions - middleware can be added later

                throw;                throw;

            }            }

        }        }



        return currentOutputContext;        return currentOutputContext;

    }    }

}}



// ===== TEST LINK IMPLEMENTATIONS =====// ===== TEST IMPLEMENTATION =====



public class StringToObjectLink : IContextLink<string, object>public class StandaloneTestRunner

{{

    public async Task<Context<object>> CallAsync(Context<string> context)    private static int _passedTests = 0;

    {    private static int _failedTests = 0;

        var value = context.Get("value");    private static readonly List<string> _testResults = new();

        return Context<object>.Create(new Dictionary<string, object>

        {    public static async Task Main(string[] args)

            ["result"] = value    {

        });        Console.WriteLine("üß™ CodeUChain C# Standalone Comprehensive Test Suite");

    }        Console.WriteLine("==================================================\n");

}

        var stopwatch = Stopwatch.StartNew();

public class DoubleValueLink : IContextLink<object, object>

{        // Core Functionality Tests

    public async Task<Context<object>> CallAsync(Context<object> context)        await TestBasicContextOperations();

    {        await TestTypedContextOperations();

        var valueStr = context.GetAny("result")?.ToString() ?? context.GetAny("value")?.ToString() ?? "0";        await TestTypeEvolution();

        if (int.TryParse(valueStr, out int value))        await TestGenericLinks();

        {        await TestGenericChains();

            return Context<object>.Create(new Dictionary<string, object>        await TestMixedUsage();

            {        await TestBackwardCompatibility();

                ["final"] = (value * 2).ToString()

            });        // Advanced Tests

        }        await TestErrorHandling();

        return context;        await TestEdgeCases();

    }        await TestPerformance();

}        await TestChainComposition();



public class DataProcessorLink : IContextLink<object, object>        // Middleware Tests

{        await TestMiddlewareFunctionality();

    public async Task<Context<object>> CallAsync(Context<object> context)        await TestAsyncOperations();

    {

        var data = context.GetAny("data")?.ToString() ?? "";        stopwatch.Stop();

        var multiplier = (int?)context.GetAny("multiplier") ?? 1;

        // Summary

        return Context<object>.Create(new Dictionary<string, object>        Console.WriteLine("\n" + "=".Repeat(50));

        {        Console.WriteLine("üìä STANDALONE COMPREHENSIVE TEST RESULTS");

            ["processed"] = data.ToUpper(),        Console.WriteLine("=".Repeat(50));

            ["calculated"] = multiplier * 2        Console.WriteLine($"Total Tests: {_passedTests + _failedTests}");

        });        Console.WriteLine($"‚úÖ Passed: {_passedTests}");

    }        Console.WriteLine($"‚ùå Failed: {_failedTests}");

}        Console.WriteLine($"‚è±Ô∏è  Execution Time: {stopwatch.Elapsed.TotalSeconds:F2} seconds");

        Console.WriteLine($"üìà Success Rate: {(_passedTests * 100.0 / (_passedTests + _failedTests)):F1}%");

public class UntypedProcessorLink : IContextLink<object, object>

{        if (_failedTests > 0)

    public async Task<Context<object>> CallAsync(Context<object> context)        {

    {            Console.WriteLine("\n‚ùå FAILED TESTS:");

        return context.Insert("untyped", "processed");            foreach (var result in _testResults.Where(r => r.Contains("‚ùå")))

    }            {

}                Console.WriteLine($"  {result}");

            }

public class TypedProcessorLink : IContextLink<object, object>        }

{

    public async Task<Context<object>> CallAsync(Context<object> context)        Console.WriteLine($"\nüéØ OVERALL STATUS: {(_failedTests == 0 ? "‚úÖ ALL TESTS PASSED" : "‚ùå SOME TESTS FAILED")}");

    {    }

        return context.Insert("typed", "processed");

    }    private static async Task TestBasicContextOperations()

}    {

        Console.WriteLine("üîç Testing Basic Context Operations...");

public class LegacyProcessor : ILink

{        // Test 1: Empty Context Creation

    public ValueTask<Context> ProcessAsync(Context context)        var emptyContext = Context.Create();

    {        Assert(emptyContext.Count == 0, "Empty context should have count 0");

        var input = context.Get("input")?.ToString() ?? "";        Assert(emptyContext.ToString() == "Context()", "Empty context string representation");

        return ValueTask.FromResult(context.Insert("output", input.ToUpper()));

    }        // Test 2: Context with Initial Data

}        var initialData = new Dictionary<string, object>

        {

public class LoggingMiddleware : IMiddleware            ["name"] = "Alice",

{            ["age"] = 30,

    public ValueTask<Context> BeforeAsync(ILink? link, Context context)            ["active"] = true

    {        };

        Console.WriteLine($"[LOG] Starting: {link?.GetType().Name ?? "Chain"}");        var context = Context.Create(initialData);

        return ValueTask.FromResult(context);        Assert(context.Count == 3, "Context should have 3 items");

    }        Assert(context.Get("name")?.ToString() == "Alice", "Should retrieve name correctly");

        Assert((int?)context.Get("age") == 30, "Should retrieve age correctly");

    public ValueTask<Context> AfterAsync(ILink? link, Context context)        Assert((bool?)context.Get("active") == true, "Should retrieve active status correctly");

    {

        Console.WriteLine($"[LOG] Completed: {link?.GetType().Name ?? "Chain"}");        // Test 3: Insert Operations

        return ValueTask.FromResult(context);        var updatedContext = context.Insert("city", "New York");

    }        Assert(updatedContext.Count == 4, "Updated context should have 4 items");

        Assert(updatedContext.Get("city")?.ToString() == "New York", "Should retrieve inserted value");

    public ValueTask<Context> OnErrorAsync(ILink? link, Exception exception, Context context)

    {        // Test 4: Remove Operations

        Console.WriteLine($"[LOG] Error in {link?.GetType().Name ?? "Chain"}: {exception.Message}");        var removedContext = updatedContext.Remove("active");

        return ValueTask.FromResult(context);        Assert(removedContext.Count == 3, "Removed context should have 3 items");

    }        Assert(removedContext.Get("active") == null, "Removed key should return null");

}

        // Test 5: Contains Key

public class ErrorLink : IContextLink<object, object>        Assert(context.ContainsKey("name"), "Should contain existing key");

{        Assert(!context.ContainsKey("nonexistent"), "Should not contain nonexistent key");

    public async Task<Context<object>> CallAsync(Context<object> context)

    {        Console.WriteLine("‚úÖ Basic Context Operations: PASSED");

        if (context.GetAny("trigger")?.ToString() == "error")    }

            throw new InvalidOperationException("Test error");

    private static async Task TestTypedContextOperations()

        return context;    {

    }        Console.WriteLine("üîç Testing Typed Context Operations...");

}

        // Test 1: Generic Context Creation

public class PerformanceLink : IContextLink<object, object>        var typedContext = Context<string>.Create();

{        Assert(typedContext.Count == 0, "Empty typed context should have count 0");

    public async Task<Context<object>> CallAsync(Context<object> context)

    {        // Test 2: Typed Context with Initial Data

        var iterations = (int?)context.GetAny("iterations") ?? 10;        var initialData = new Dictionary<string, object>

        var total = (int?)context.GetAny("total") ?? 0;        {

            ["message"] = "Hello World",

        // Simulate some processing            ["count"] = 42

        for (int i = 0; i < iterations; i++)        };

        {        var context = Context<string>.Create(initialData);

            total += 1;        Assert(context.Count == 2, "Typed context should have 2 items");

            await Task.Delay(1); // Small delay to simulate work

        }        // Test 3: Typed Get Operations

        var message = context.Get("message");

        return Context<object>.Create(new Dictionary<string, object>        Assert(message == "Hello World", "Should retrieve typed string value");

        {

            ["total"] = total.ToString()        var count = context.Get("count");

        });        Assert(count == null, "Should return null for non-string type");

    }

}        // Test 4: GetAny Operations

        var anyMessage = context.GetAny("message");

public class ObjectToStringLink : IContextLink<object, object>        Assert(anyMessage?.ToString() == "Hello World", "GetAny should retrieve any type");

{

    public async Task<Context<object>> CallAsync(Context<object> context)        var anyCount = context.GetAny("count");

    {        Assert((int?)anyCount == 42, "GetAny should retrieve integer value");

        var value = context.GetAny("value")?.ToString() ?? "0";

        return Context<object>.Create(new Dictionary<string, object>        Console.WriteLine("‚úÖ Typed Context Operations: PASSED");

        {    }

            ["string"] = value

        });    private static async Task TestTypeEvolution()

    }    {

}        Console.WriteLine("üîç Testing Type Evolution...");



public class NestedChainLink : IContextLink<object, object>        // Test 1: Basic Type Evolution

{        var stringContext = Context<string>.Create(new Dictionary<string, object>

    private readonly Chain<object, object> _innerChain;        {

            ["data"] = "initial"

    public NestedChainLink(Chain<object, object> innerChain)        });

    {

        _innerChain = innerChain;        var objectContext = stringContext.InsertAs<object>("number", 100);

    }        Assert(objectContext.GetAny("number")?.ToString() == "100", "Should retrieve value from evolved context");

        Assert(objectContext.Get("data") == null, "Should not retrieve string from object context");

    public async Task<Context<object>> CallAsync(Context<object> context)

    {        // Test 2: Chain Type Evolution

        return await _innerChain.RunAsync(context);        var context1 = Context<object>.Create(new Dictionary<string, object>

    }        {

}            ["step"] = 1

        });

public class SimpleLink : ILink

{        var context2 = context1.InsertAs<string>("message", "processing");

    public ValueTask<Context> ProcessAsync(Context context)        var context3 = context2.InsertAs<object>("result", 42);

    {

        var input = context.Get("input")?.ToString() ?? "";        Assert(context3.GetAny("result")?.ToString() == "42", "Final context should have result");

        return ValueTask.FromResult(context.Insert("processed", input.ToUpper()));        Assert(context3.Get("message") == null, "Final context should not have string message");

    }

}        Console.WriteLine("‚úÖ Type Evolution: PASSED");

    }

public class TimingMiddleware : IMiddleware

{    private static async Task TestGenericLinks()

    public ValueTask<Context> BeforeAsync(ILink? link, Context context)    {

    {        Console.WriteLine("üîç Testing Generic Links...");

        return ValueTask.FromResult(context.Insert("start", DateTime.Now));

    }        // Test 1: Simple Generic Link

        var stringToObjectLink = new StringToObjectLink();

    public ValueTask<Context> AfterAsync(ILink? link, Context context)        var inputContext = Context<string>.Create(new Dictionary<string, object>

    {        {

        var start = (DateTime?)context.Get("start");            ["value"] = "42"

        if (start.HasValue)        });

        {

            var duration = DateTime.Now - start.Value;        var outputContext = await stringToObjectLink.CallAsync(inputContext);

            return ValueTask.FromResult(context.Insert("duration", duration.TotalMilliseconds));        Assert(outputContext.GetAny("result")?.ToString() == "42", "Link should convert string to object");

        }

        return ValueTask.FromResult(context);        // Test 2: Complex Generic Link

    }        var processorLink = new DataProcessorLink();

        var complexInput = Context<object>.Create(new Dictionary<string, object>

    public ValueTask<Context> OnErrorAsync(ILink? link, Exception exception, Context context)        {

    {            ["data"] = "test",

        return ValueTask.FromResult(context);            ["multiplier"] = 2

    }        });

}

        var complexOutput = await processorLink.CallAsync(complexInput);

public class AsyncDelayLink : ILink        Assert(complexOutput.GetAny("processed")?.ToString() == "TEST", "Should process string to uppercase");

{        Assert(complexOutput.GetAny("calculated") == 4, "Should calculate doubled value");

    public async ValueTask<Context> ProcessAsync(Context context)

    {        Console.WriteLine("‚úÖ Generic Links: PASSED");

        var delay = (int?)context.Get("delay") ?? 100;    }

        await Task.Delay(delay);

        return context.Insert("delayed", true);    private static async Task TestGenericChains()

    }    {

}        Console.WriteLine("üîç Testing Generic Chains...");



// ===== TEST IMPLEMENTATION =====        // Test 1: Simple Generic Chain

        var chain = new Chain<string, object>()

public class StandaloneTestRunner            .AddLink("parse", new StringToObjectLink())

{            .AddLink("double", new DoubleValueLink());

    private static int _passedTests = 0;

    private static int _failedTests = 0;        var input = Context<string>.Create(new Dictionary<string, object>

    private static readonly List<string> _testResults = new();        {

            ["value"] = "21"

    public static async Task Main(string[] args)        });

    {

        Console.WriteLine("üß™ CodeUChain C# Standalone Comprehensive Test Suite");        var result = await chain.RunAsync(input);

        Console.WriteLine("==================================================\n");        Assert(result.GetAny("final")?.ToString() == "42", "Chain should process string to doubled value");



        var stopwatch = Stopwatch.StartNew();        Console.WriteLine("‚úÖ Generic Chains: PASSED");

    }

        // Core Functionality Tests

        await TestBasicContextOperations();    private static async Task TestMixedUsage()

        await TestTypedContextOperations();    {

        await TestTypeEvolution();        Console.WriteLine("üîç Testing Mixed Usage...");

        await TestGenericLinks();

        await TestGenericChains();        // Test 1: Mixed Typed and Untyped Contexts

        await TestMixedUsage();        var untypedContext = Context.Create(new Dictionary<string, object>

        await TestBackwardCompatibility();        {

            ["data"] = "mixed"

        // Advanced Tests        });

        await TestErrorHandling();

        await TestEdgeCases();        var typedContext = Context<string>.Create(new Dictionary<string, object>

        await TestPerformance();        {

        await TestChainComposition();            ["typed"] = "data"

        });

        // Middleware Tests

        await TestMiddlewareFunctionality();        // Test 2: Mixed Links

        await TestAsyncOperations();        var mixedChain = new Chain<object, object>()

            .AddLink("untyped", new UntypedProcessorLink())

        stopwatch.Stop();            .AddLink("typed", new TypedProcessorLink());



        // Summary        var mixedResult = await mixedChain.RunAsync(untypedContext);

        Console.WriteLine("\n" + "=".Repeat(50));        Assert(mixedResult.GetAny("processed") != null, "Mixed chain should process successfully");

        Console.WriteLine("üìä STANDALONE COMPREHENSIVE TEST RESULTS");

        Console.WriteLine("=".Repeat(50));        Console.WriteLine("‚úÖ Mixed Usage: PASSED");

        Console.WriteLine($"Total Tests: {_passedTests + _failedTests}");    }

        Console.WriteLine($"‚úÖ Passed: {_passedTests}");

        Console.WriteLine($"‚ùå Failed: {_failedTests}");    private static async Task TestBackwardCompatibility()

        Console.WriteLine($"‚è±Ô∏è  Execution Time: {stopwatch.Elapsed.TotalSeconds:F2} seconds");    {

        Console.WriteLine($"üìà Success Rate: {(_passedTests * 100.0 / (_passedTests + _failedTests)):F1}%");        Console.WriteLine("üîç Testing Backward Compatibility...");



        if (_failedTests > 0)        // Test 1: Original Untyped Chain

        {        var untypedChain = new Chain()

            Console.WriteLine("\n‚ùå FAILED TESTS:");            .AddLink("process", new LegacyProcessor())

            foreach (var result in _testResults.Where(r => r.Contains("‚ùå")))            .UseMiddleware(new LoggingMiddleware());

            {

                Console.WriteLine($"  {result}");        var untypedInput = Context.Create(new Dictionary<string, object>

            }        {

        }            ["input"] = "legacy"

        });

        Console.WriteLine($"\nüéØ OVERALL STATUS: {(_failedTests == 0 ? "‚úÖ ALL TESTS PASSED" : "‚ùå SOME TESTS FAILED")}");

    }        var untypedResult = await untypedChain.RunAsync(untypedInput);

        Assert(untypedResult.Get("output")?.ToString() == "LEGACY", "Untyped chain should work");

    private static async Task TestBasicContextOperations()

    {        Console.WriteLine("‚úÖ Backward Compatibility: PASSED");

        Console.WriteLine("üîç Testing Basic Context Operations...");    }



        // Test 1: Empty Context Creation    private static async Task TestErrorHandling()

        var emptyContext = Context.Create();    {

        Assert(emptyContext.Count == 0, "Empty context should have count 0");        Console.WriteLine("üîç Testing Error Handling...");

        Assert(emptyContext.ToString() == "Context()", "Empty context string representation");

        // Test 1: Link Error Handling

        // Test 2: Context with Initial Data        var errorChain = new Chain<object, object>()

        var initialData = new Dictionary<string, object>            .AddLink("error", new ErrorLink());

        {

            ["name"] = "Alice",        var errorInput = Context<object>.Create(new Dictionary<string, object>

            ["age"] = 30,        {

            ["active"] = true            ["trigger"] = "error"

        };        });

        var context = Context.Create(initialData);

        Assert(context.Count == 3, "Context should have 3 items");        try

        Assert(context.Get("name")?.ToString() == "Alice", "Should retrieve name correctly");        {

        Assert((int?)context.Get("age") == 30, "Should retrieve age correctly");            await errorChain.RunAsync(errorInput);

        Assert((bool?)context.Get("active") == true, "Should retrieve active status correctly");            Assert(false, "Should have thrown exception");

        }

        // Test 3: Insert Operations        catch (InvalidOperationException ex)

        var updatedContext = context.Insert("city", "New York");        {

        Assert(updatedContext.Count == 4, "Updated context should have 4 items");            Assert(ex.Message == "Test error", "Should catch correct exception");

        Assert(updatedContext.Get("city")?.ToString() == "New York", "Should retrieve inserted value");        }



        // Test 4: Remove Operations        Console.WriteLine("‚úÖ Error Handling: PASSED");

        var removedContext = updatedContext.Remove("active");    }

        Assert(removedContext.Count == 3, "Removed context should have 3 items");

        Assert(removedContext.Get("active") == null, "Removed key should return null");    private static async Task TestEdgeCases()

    {

        // Test 5: Contains Key        Console.WriteLine("üîç Testing Edge Cases...");

        Assert(context.ContainsKey("name"), "Should contain existing key");

        Assert(!context.ContainsKey("nonexistent"), "Should not contain nonexistent key");        // Test 1: Empty Chains

        var emptyChain = new Chain<object, object>();

        Console.WriteLine("‚úÖ Basic Context Operations: PASSED");        var emptyResult = await emptyChain.RunAsync(Context<object>.Create());

    }        Assert(emptyResult.Count == 0, "Empty chain should return empty context");



    private static async Task TestTypedContextOperations()        // Test 2: Null Values

    {        var nullContext = Context.Create();

        Console.WriteLine("üîç Testing Typed Context Operations...");        nullContext = nullContext.Insert("nullValue", null);

        Assert(nullContext.Get("nullValue") == null, "Should handle null values");

        // Test 1: Generic Context Creation

        var typedContext = Context<string>.Create();        Console.WriteLine("‚úÖ Edge Cases: PASSED");

        Assert(typedContext.Count == 0, "Empty typed context should have count 0");    }



        // Test 2: Typed Context with Initial Data    private static async Task TestPerformance()

        var initialData = new Dictionary<string, object>    {

        {        Console.WriteLine("üîç Testing Performance...");

            ["message"] = "Hello World",

            ["count"] = 42        var stopwatch = Stopwatch.StartNew();

        };

        var context = Context<string>.Create(initialData);        // Test 1: Chain Performance

        Assert(context.Count == 2, "Typed context should have 2 items");        var perfChain = new Chain<object, object>()

            .AddLink("step1", new PerformanceLink())

        // Test 3: Typed Get Operations            .AddLink("step2", new PerformanceLink())

        var message = context.Get("message");            .AddLink("step3", new PerformanceLink());

        Assert(message == "Hello World", "Should retrieve typed string value");

        var perfInput = Context<object>.Create(new Dictionary<string, object>

        var count = context.Get("count");        {

        Assert(count == null, "Should return null for non-string type");            ["iterations"] = 10

        });

        // Test 4: GetAny Operations

        var anyMessage = context.GetAny("message");        stopwatch.Start();

        Assert(anyMessage?.ToString() == "Hello World", "GetAny should retrieve any type");        var perfResult = await perfChain.RunAsync(perfInput);

        stopwatch.Stop();

        var anyCount = context.GetAny("count");

        Assert((int?)anyCount == 42, "GetAny should retrieve integer value");        var executionTime = stopwatch.Elapsed.TotalMilliseconds;

        Assert(executionTime < 1000, $"Chain should execute quickly, took {executionTime}ms");

        Console.WriteLine("‚úÖ Typed Context Operations: PASSED");        Assert(perfResult.GetAny("total")?.ToString() == "30", "Should accumulate results correctly");

    }

        Console.WriteLine($"‚úÖ Performance: PASSED ({executionTime:F2}ms)");

    private static async Task TestTypeEvolution()    }

    {

        Console.WriteLine("üîç Testing Type Evolution...");    private static async Task TestChainComposition()

    {

        // Test 1: Basic Type Evolution        Console.WriteLine("üîç Testing Chain Composition...");

        var stringContext = Context<string>.Create(new Dictionary<string, object>

        {        // Test 1: Nested Chains

            ["data"] = "initial"        var innerChain = new Chain<object, object>()

        });            .AddLink("double", new DoubleValueLink());



        var objectContext = stringContext.InsertAs<object>("number", 100);        var outerChain = new Chain<object, object>()

        Assert(objectContext.GetAny("number")?.ToString() == "100", "Should retrieve value from evolved context");            .AddLink("convert", new ObjectToStringLink())

        Assert(objectContext.Get("data") == null, "Should not retrieve string from object context");            .AddLink("process", new NestedChainLink(innerChain))

            .AddLink("format", new StringToObjectLink());

        // Test 2: Chain Type Evolution

        var context1 = Context<object>.Create(new Dictionary<string, object>        var nestedInput = Context<object>.Create(new Dictionary<string, object>

        {        {

            ["step"] = 1            ["value"] = "10"

        });        });



        var context2 = context1.InsertAs<string>("message", "processing");        var nestedResult = await outerChain.RunAsync(nestedInput);

        var context3 = context2.InsertAs<object>("result", 42);        Assert(nestedResult.GetAny("final")?.ToString() == "40", "Nested chain should work correctly");



        Assert(context3.GetAny("result")?.ToString() == "42", "Final context should have result");        Console.WriteLine("‚úÖ Chain Composition: PASSED");

        Assert(context3.Get("message") == null, "Final context should not have string message");    }



        Console.WriteLine("‚úÖ Type Evolution: PASSED");    private static async Task TestMiddlewareFunctionality()

    }    {

        Console.WriteLine("üîç Testing Middleware Functionality...");

    private static async Task TestGenericLinks()

    {        // Test 1: Basic Middleware

        Console.WriteLine("üîç Testing Generic Links...");        var middlewareChain = new Chain()

            .AddLink("process", new SimpleLink())

        // Test 1: Simple Generic Link            .UseMiddleware(new TimingMiddleware())

        var stringToObjectLink = new StringToObjectLink();            .UseMiddleware(new LoggingMiddleware());

        var inputContext = Context<string>.Create(new Dictionary<string, object>

        {        var middlewareInput = Context.Create(new Dictionary<string, object>

            ["value"] = "42"        {

        });            ["input"] = "test"

        });

        var outputContext = await stringToObjectLink.CallAsync(inputContext);

        Assert(outputContext.GetAny("result")?.ToString() == "42", "Link should convert string to object");        var middlewareResult = await middlewareChain.RunAsync(middlewareInput);

        Assert(middlewareResult.Get("processed")?.ToString() == "TEST", "Middleware chain should work");

        // Test 2: Complex Generic Link

        var processorLink = new DataProcessorLink();        Console.WriteLine("‚úÖ Middleware Functionality: PASSED");

        var complexInput = Context<object>.Create(new Dictionary<string, object>    }

        {

            ["data"] = "test",    private static async Task TestAsyncOperations()

            ["multiplier"] = 2    {

        });        Console.WriteLine("üîç Testing Async Operations...");



        var complexOutput = await processorLink.CallAsync(complexInput);        // Test 1: Async Links

        Assert(complexOutput.GetAny("processed")?.ToString() == "TEST", "Should process string to uppercase");        var asyncChain = new Chain()

        Assert(complexOutput.GetAny("calculated") == 4, "Should calculate doubled value");            .AddLink("async1", new AsyncDelayLink())

            .AddLink("async2", new AsyncDelayLink());

        Console.WriteLine("‚úÖ Generic Links: PASSED");

    }        var asyncInput = Context.Create(new Dictionary<string, object>

        {

    private static async Task TestGenericChains()            ["delay"] = 10

    {        });

        Console.WriteLine("üîç Testing Generic Chains...");

        var stopwatch = Stopwatch.StartNew();

        // Test 1: Simple Generic Chain        var asyncResult = await asyncChain.RunAsync(asyncInput);

        var chain = new Chain<string, object>()        stopwatch.Stop();

            .AddLink("parse", new StringToObjectLink())

            .AddLink("double", new DoubleValueLink());        // Should complete in ~20ms (2 delays of 10ms each)

        Assert(stopwatch.Elapsed.TotalMilliseconds < 100, "Async operations should be efficient");

        var input = Context<string>.Create(new Dictionary<string, object>        Assert(asyncResult.Get("delayed") != null, "Async chain should complete successfully");

        {

            ["value"] = "21"        Console.WriteLine($"‚úÖ Async Operations: PASSED ({stopwatch.Elapsed.TotalMilliseconds:F2}ms)");

        });    }



        var result = await chain.RunAsync(input);    private static void Assert(bool condition, string message)

        Assert(result.GetAny("final")?.ToString() == "42", "Chain should process string to doubled value");    {

        if (condition)

        Console.WriteLine("‚úÖ Generic Chains: PASSED");        {

    }            _passedTests++;

            _testResults.Add($"‚úÖ {message}");

    private static async Task TestMixedUsage()        }

    {        else

        Console.WriteLine("üîç Testing Mixed Usage...");        {

            _failedTests++;

        // Test 1: Mixed Typed and Untyped Contexts            _testResults.Add($"‚ùå {message}");

        var untypedContext = Context.Create(new Dictionary<string, object>            Console.WriteLine($"‚ùå ASSERTION FAILED: {message}");

        {        }

            ["data"] = "mixed"    }

        });}

        var typedContext = Context<string>.Create(new Dictionary<string, object>
        {
            ["typed"] = "data"
        });

        // Test 2: Mixed Links
        var mixedChain = new Chain<object, object>()
            .AddLink("untyped", new UntypedProcessorLink())
            .AddLink("typed", new TypedProcessorLink());

        var mixedResult = await mixedChain.RunAsync(untypedContext);
        Assert(mixedResult.GetAny("processed") != null, "Mixed chain should process successfully");

        Console.WriteLine("‚úÖ Mixed Usage: PASSED");
    }

    private static async Task TestBackwardCompatibility()
    {
        Console.WriteLine("üîç Testing Backward Compatibility...");

        // Test 1: Original Untyped Chain
        var untypedChain = new Chain()
            .AddLink("process", new LegacyProcessor())
            .UseMiddleware(new LoggingMiddleware());

        var untypedInput = Context.Create(new Dictionary<string, object>
        {
            ["input"] = "legacy"
        });

        var untypedResult = await untypedChain.RunAsync(untypedInput);
        Assert(untypedResult.Get("output")?.ToString() == "LEGACY", "Untyped chain should work");

        Console.WriteLine("‚úÖ Backward Compatibility: PASSED");
    }

    private static async Task TestErrorHandling()
    {
        Console.WriteLine("üîç Testing Error Handling...");

        // Test 1: Link Error Handling
        var errorChain = new Chain<object, object>()
            .AddLink("error", new ErrorLink());

        var errorInput = Context<object>.Create(new Dictionary<string, object>
        {
            ["trigger"] = "error"
        });

        try
        {
            await errorChain.RunAsync(errorInput);
            Assert(false, "Should have thrown exception");
        }
        catch (InvalidOperationException ex)
        {
            Assert(ex.Message == "Test error", "Should catch correct exception");
        }

        Console.WriteLine("‚úÖ Error Handling: PASSED");
    }

    private static async Task TestEdgeCases()
    {
        Console.WriteLine("üîç Testing Edge Cases...");

        // Test 1: Empty Chains
        var emptyChain = new Chain<object, object>();
        var emptyResult = await emptyChain.RunAsync(Context<object>.Create());
        Assert(emptyResult.Count == 0, "Empty chain should return empty context");

        // Test 2: Null Values
        var nullContext = Context.Create();
        nullContext = nullContext.Insert("nullValue", null);
        Assert(nullContext.Get("nullValue") == null, "Should handle null values");

        Console.WriteLine("‚úÖ Edge Cases: PASSED");
    }

    private static async Task TestPerformance()
    {
        Console.WriteLine("üîç Testing Performance...");

        var stopwatch = Stopwatch.StartNew();

        // Test 1: Chain Performance
        var perfChain = new Chain<object, object>()
            .AddLink("step1", new PerformanceLink())
            .AddLink("step2", new PerformanceLink())
            .AddLink("step3", new PerformanceLink());

        var perfInput = Context<object>.Create(new Dictionary<string, object>
        {
            ["iterations"] = 10
        });

        stopwatch.Start();
        var perfResult = await perfChain.RunAsync(perfInput);
        stopwatch.Stop();

        var executionTime = stopwatch.Elapsed.TotalMilliseconds;
        Assert(executionTime < 1000, $"Chain should execute quickly, took {executionTime}ms");
        Assert(perfResult.GetAny("total")?.ToString() == "30", "Should accumulate results correctly");

        Console.WriteLine($"‚úÖ Performance: PASSED ({executionTime:F2}ms)");
    }

    private static async Task TestChainComposition()
    {
        Console.WriteLine("üîç Testing Chain Composition...");

        // Test 1: Nested Chains
        var innerChain = new Chain<object, object>()
            .AddLink("double", new DoubleValueLink());

        var outerChain = new Chain<object, object>()
            .AddLink("convert", new ObjectToStringLink())
            .AddLink("process", new NestedChainLink(innerChain))
            .AddLink("format", new StringToObjectLink());

        var nestedInput = Context<object>.Create(new Dictionary<string, object>
        {
            ["value"] = "10"
        });

        var nestedResult = await outerChain.RunAsync(nestedInput);
        Assert(nestedResult.GetAny("final")?.ToString() == "40", "Nested chain should work correctly");

        Console.WriteLine("‚úÖ Chain Composition: PASSED");
    }

    private static async Task TestMiddlewareFunctionality()
    {
        Console.WriteLine("üîç Testing Middleware Functionality...");

        // Test 1: Basic Middleware
        var middlewareChain = new Chain()
            .AddLink("process", new SimpleLink())
            .UseMiddleware(new TimingMiddleware())
            .UseMiddleware(new LoggingMiddleware());

        var middlewareInput = Context.Create(new Dictionary<string, object>
        {
            ["input"] = "test"
        });

        var middlewareResult = await middlewareChain.RunAsync(middlewareInput);
        Assert(middlewareResult.Get("processed")?.ToString() == "TEST", "Middleware chain should work");

        Console.WriteLine("‚úÖ Middleware Functionality: PASSED");
    }

    private static async Task TestAsyncOperations()
    {
        Console.WriteLine("üîç Testing Async Operations...");

        // Test 1: Async Links
        var asyncChain = new Chain()
            .AddLink("async1", new AsyncDelayLink())
            .AddLink("async2", new AsyncDelayLink());

        var asyncInput = Context.Create(new Dictionary<string, object>
        {
            ["delay"] = 10
        });

        var stopwatch = Stopwatch.StartNew();
        var asyncResult = await asyncChain.RunAsync(asyncInput);
        stopwatch.Stop();

        // Should complete in ~20ms (2 delays of 10ms each)
        Assert(stopwatch.Elapsed.TotalMilliseconds < 100, "Async operations should be efficient");
        Assert(asyncResult.Get("delayed") != null, "Async chain should complete successfully");

        Console.WriteLine($"‚úÖ Async Operations: PASSED ({stopwatch.Elapsed.TotalMilliseconds:F2}ms)");
    }

    private static void Assert(bool condition, string message)
    {
        if (condition)
        {
            _passedTests++;
            _testResults.Add($"‚úÖ {message}");
        }
        else
        {
            _failedTests++;
            _testResults.Add($"‚ùå {message}");
            Console.WriteLine($"‚ùå ASSERTION FAILED: {message}");
        }
    }
}